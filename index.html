<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" /> <!-- Zapobiega zoomowaniu na mobilnych -->
    <title>MiniSoccer - Szybki Mecz</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* GLOBALNE STYLE – DESIGN W PIŁKARSKIM KLIMACIE */
      html, body {
        overscroll-behavior-y: contain; /* Zapobiega odświeżaniu przez pociągnięcie w dół */
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden; /* Zapobiega przewijaniu całej strony */
      }
      body {
        font-family: "Nunito", sans-serif;
        background: url("https://images.unsplash.com/photo-1578985545062-69928b1d9587?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80")
          no-repeat center center fixed;
        background-size: cover;
        text-align: center;
        color: #fff;
        display: flex; /* Użyj flexbox do centrowania */
        align-items: center;
        justify-content: center;
      }
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.4); /* Ciemniejsze tło */
        z-index: -1;
      }
       .screen-container { /* Kontener dla ekranów gry */
         width: 100%;
         max-width: 950px; /* Maksymalna szerokość */
         padding: 10px;
         box-sizing: border-box;
       }

      .hidden { display: none !important; }

      /* EKRAN STARTOWY */
      #startScreen {
        padding: 20px;
      }
      #startScreen h1 {
        font-size: clamp(36px, 8vw, 56px); /* Responsywny rozmiar czcionki */
        margin-bottom: 20px;
        text-shadow: 2px 2px 5px rgba(0,0,0,0.4);
      }
      #startScreen button {
        font-size: clamp(16px, 4vw, 20px);
        padding: 12px 25px;
        margin: 10px 5px;
        border: none;
        border-radius: 10px;
        background-color: rgba(255,255,255,0.85);
        cursor: pointer;
        color: #333;
        box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
        font-weight: 600;
      }
      #startScreen button:hover:not(:disabled) {
        background-color: #fff;
        transform: scale(1.05);
        box-shadow: 0px 5px 15px rgba(0,0,0,0.3);
      }
       .start-options { margin-top: 20px;}
       .start-options button { /* Style dla mniejszych przycisków opcji */
        font-size: clamp(13px, 3vw, 16px);
        padding: 8px 15px;
        margin: 5px;
        background-color: rgba(255, 255, 255, 0.7);
       }
        .start-options button:disabled {
           opacity: 0.5;
           cursor: not-allowed;
        }


      /* EKRAN WYBORU DRUŻYN */
      #teamSelectScreen { padding: 20px; max-height: 90vh; overflow-y: auto;} /* Przewijanie całego ekranu wyboru */
      #teamSelectScreen h2 {
        font-size: clamp(28px, 6vw, 40px);
        margin-bottom: 15px;
        text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
      }
      .team-section {
        margin: 20px auto;
        text-align: left;
        background-color: rgba(0, 0, 0, 0.25); /* Lekkie tło dla sekcji */
        padding: 15px;
        border-radius: 10px;
      }
      .team-section h3 {
          font-size: clamp(20px, 5vw, 26px);
          margin: 0 0 15px 0;
          padding-left: 5px;
          border-bottom: 1px solid rgba(255,255,255,0.3);
          padding-bottom: 8px;
          display: flex; /* Aby nazwa drużyny była obok */
          justify-content: space-between;
          align-items: center;
       }
        .team-section h3 span { /* Styl dla wybranej nazwy drużyny */
           font-size: 0.7em;
           font-weight: normal;
           color: #ffd700;
           margin-left: 10px;
           overflow: hidden;
           white-space: nowrap;
           text-overflow: ellipsis;
           max-width: 50%; /* Ogranicz szerokość nazwy */
       }
      .team-container { /* Kontener dla lig */
        display: block;
      }
       .league-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        padding-left: 5px;
        font-size: clamp(16px, 4vw, 20px);
        font-weight: bold;
      }
      .league-header img { width: 25px; height: auto; flex-shrink: 0;}

      .team-row { /* Kontener dla drużyn w danej lidze */
        display: flex;
        gap: 10px; /* Odstęp między drużynami */
        overflow-x: auto; /* Przewijanie poziome dla drużyn */
        padding: 10px 5px; /* Padding góra/dół i lekki boczny */
        scrollbar-width: thin;
        scrollbar-color: #ffd700 rgba(255,255,255,0.1);
        margin-bottom: 15px; /* Odstęp pod rzędem drużyn */
      }

       .team-row::-webkit-scrollbar { height: 6px; }
      .team-row::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 3px;}
      .team-row::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 3px;}


      .team-option {
        cursor: pointer;
        text-align: center;
        border: 3px solid rgba(255,255,255,0.5);
        border-radius: 10px;
        width: 120px; /* Nieco mniejsze karty */
        padding: 8px;
        transition: all 0.2s ease;
        flex: 0 0 120px; /* Zapobiega rozciąganiu */
        background-color: rgba(255,255,255, 0.1);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        overflow: hidden; /* Ukryj wystające elementy */
      }
      .team-option:hover {
          border-color: #fff;
          background-color: rgba(255,255,255, 0.2);
      }
      .team-option.selected {
        border-color: #ffd700;
        transform: scale(1.05);
        background-color: rgba(255, 215, 0, 0.3);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      }
      .team-option img {
        width: 60px;
        height: 60px;
        display: block;
        margin: 0 auto 8px;
        object-fit: contain;
      }
      .team-option p {
          font-size: 13px;
          margin: 0;
          line-height: 1.2;
          height: 2.4em; /* Zapewnia miejsce na max 2 linie */
          overflow: hidden;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: 600;
      }
      #startMatchFromSelectBtn {
        font-size: clamp(16px, 4vw, 20px);
        padding: 12px 25px;
        margin-top: 20px;
        cursor: pointer;
        background-color: #ffd700;
        color: #333;
        border: none;
        border-radius: 12px;
        transition: all 0.2s ease;
        box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        font-weight: bold;
        display: block; /* Wyśrodkuj przycisk */
        margin-left: auto;
        margin-right: auto;
      }
      #startMatchFromSelectBtn:hover:not(:disabled) {
        background-color: #fff;
        transform: scale(1.05);
        box-shadow: 0px 5px 15px rgba(0,0,0,0.3);
      }
       #startMatchFromSelectBtn:disabled {
         background-color: #aaa;
         cursor: not-allowed;
         opacity: 0.6;
         box-shadow: none;
       }

      /* EKRAN GRY */
      #gameScreen { padding: 10px 0; } /* Zmniejszony padding */
      #scoreboardContainer {
          margin-bottom: 10px;
          background-color: rgba(0, 0, 0, 0.6);
          padding: 8px 15px;
          border-radius: 8px;
          display: inline-block;
          font-size: clamp(14px, 3.5vw, 18px); /* Responsywny scoreboard */
       }
      #scoreboard { font-weight: bold; margin: 0 0 3px 0; display: inline-block; }
      #matchTimer { margin: 0; display: inline-block; margin-left: 15px; }
      canvas {
        background-color: #1E8449;
        border: 3px solid #fff;
        border-radius: 12px;
        display: block;
        margin: 0 auto;
        box-shadow: 0px 6px 12px rgba(0,0,0,0.3);
        max-width: 100%; /* Canvas nie będzie szerszy niż kontener */
        height: auto; /* Wysokość dopasuje się do szerokości */
        aspect-ratio: 800 / 500; /* Utrzymaj proporcje 8:5 */
      }
      #backToStartBtn {
        font-size: clamp(14px, 3.5vw, 18px);
        padding: 10px 20px;
        margin-top: 15px;
        cursor: pointer;
        background: rgba(255,255,255,0.9);
        color: #333;
        border: none;
        border-radius: 10px;
        transition: all 0.2s;
        box-shadow: 0px 3px 6px rgba(0,0,0,0.2);
        font-weight: 600;
      }
      #backToStartBtn:hover { background: rgba(255,255,255,1); transform: scale(1.03);}

      /* MODALE (style bez zmian, ale można je ukryć jeśli nieużywane) */
      /* ... style modali ... */
        .modal {
          position: fixed; /* Użyj fixed zamiast absolute */
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 100;
          animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .modal-content {
          background: #f0f0f0;
          padding: 20px;
          width: 90%;
          max-width: 450px; /* Mniejszy modal */
          border-radius: 12px;
          box-shadow: 0 6px 12px rgba(0,0,0,0.3);
          color: #333;
        }
         .modal-content h2 { margin-top: 0; font-size: clamp(20px, 5vw, 26px); color: #1a6a35; }
         .modal-content button {
            background: #1a6a35;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 18px;
            margin: 10px 5px 0 5px;
            transition: all 0.2s;
            box-shadow: 0px 2px 4px rgba(0,0,0,0.25);
            cursor: pointer;
            font-size: clamp(14px, 3.5vw, 16px);
            font-weight: 600;
         }
         .modal-content button:hover:not(:disabled) {
            background: #228B22;
            transform: translateY(-2px);
         }
         .modal-content button.close-btn { background-color: #aaa; }
         .modal-content button.close-btn:hover { background-color: #888; }
         input { /* Style dla inputów, jeśli będą używane */
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            width: calc(100% - 22px);
            box-sizing: border-box;
            font-size: clamp(14px, 3.5vw, 16px);
         }

      /* Poprawki dla niskich ekranów (np. poziomo na mobilnych) */
        @media (max-height: 500px) and (min-width: 600px) {
             #startScreen h1 { margin-bottom: 10px; }
             #startScreen button { padding: 10px 20px; margin: 8px 5px;}
             .start-options { margin-top: 10px; }
             #teamSelectScreen { padding: 10px; }
             #teamSelectScreen h2 { margin-bottom: 10px; }
             .team-section { margin: 10px auto; padding: 10px;}
             .team-section h3 { font-size: 18px; margin-bottom: 10px; }
             .league-header { font-size: 15px; }
             .team-option { width: 100px; flex-basis: 100px; padding: 5px;}
             .team-option img { width: 45px; height: 45px; margin-bottom: 5px;}
             .team-option p { font-size: 11px; height: 2.2em;}
             #startMatchFromSelectBtn { margin-top: 10px; padding: 10px 20px; }
             #gameScreen { padding: 5px 0;}
             #scoreboardContainer { margin-bottom: 5px; padding: 5px 10px; font-size: 13px;}
             #matchTimer { margin-left: 10px; }
             #backToStartBtn { margin-top: 10px; padding: 8px 15px; }
        }

    </style>
  </head>
  <body>
    <div class="screen-container"> <!-- Dodano kontener -->
        <!-- EKRAN STARTOWY -->
        <div id="startScreen">
          <h1>MiniSoccer ⚽</h1>
          <button id="startMatchBtn">SZYBKI MECZ</button>
          <div class="start-options">
            <button id="btnPlayerDB" disabled title="Funkcja niedostępna">Baza zawodników</button>
            <button id="btnLanguage" disabled title="Funkcja niedostępna">Język</button>
            <button id="btnSettings" disabled title="Funkcja niedostępna">Ustawienia</button>
          </div>
        </div>

        <!-- EKRAN WYBORU DRUŻYN -->
        <div id="teamSelectScreen" class="hidden">
          <h2>Wybierz Drużyny</h2>
          <div class="team-section" id="homeTeamSection">
            <h3>Drużyna Domowa <span id="selectedHomeTeamName"></span></h3>
            <div id="homeTeamContainer" class="team-container"></div>
          </div>
          <div class="team-section" id="awayTeamSection">
            <h3>Drużyna Gościa <span id="selectedAwayTeamName"></span></h3>
            <div id="awayTeamContainer" class="team-container"></div>
          </div>
          <button id="startMatchFromSelectBtn" disabled>Wybierz obie drużyny</button>
        </div>

        <!-- EKRAN GRY -->
        <div id="gameScreen" class="hidden">
          <div id="scoreboardContainer">
            <h2 id="scoreboard">— : —</h2>
            <h3 id="matchTimer">Czas: 3:00</h3>
          </div>
          <canvas id="gameCanvas" width="800" height="500"></canvas>
          <button id="backToStartBtn">Powrót do Menu</button>
        </div>

        <!-- MODALE -->
        <!-- ... (kod modali bez zmian) ... -->

        <!-- ELEMENT AUDIO -->
        <audio id="backgroundMusic" loop>
          <!-- !!! SPRAWDŹ I POPRAW TĘ ŚCIEŻKĘ !!! -->
          <!-- Przykład 1 (plik w tym samym folderze): src="muzyka_tla.mp3" -->
          <!-- Przykład 2 (plik w folderze audio):    src="audio/muzyka_tla.mp3" -->
          <source src="path/to/your/music.mp3" type="audio/mpeg">
          Twoja przeglądarka nie obsługuje elementu audio.
        </audio>
    </div> <!-- Koniec screen-container -->

    <script>
      (function () {
        "use strict";

        // --- Referencje do elementów DOM ---
        const startScreen = document.getElementById('startScreen');
        const teamSelectScreen = document.getElementById('teamSelectScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startMatchBtn = document.getElementById('startMatchBtn');
        const startMatchFromSelectBtn = document.getElementById('startMatchFromSelectBtn');
        const backToStartBtn = document.getElementById('backToStartBtn');
        const homeTeamContainer = document.getElementById("homeTeamContainer");
        const awayTeamContainer = document.getElementById("awayTeamContainer");
        const selectedHomeTeamNameSpan = document.getElementById('selectedHomeTeamName');
        const selectedAwayTeamNameSpan = document.getElementById('selectedAwayTeamName');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const scoreboardEl = document.getElementById("scoreboard");
        const matchTimerEl = document.getElementById("matchTimer");
        let canvas, ctx; // Inicjowane w initGame

        // --- Stan gry ---
        let score = { home: 0, away: 0 };
        let ball = {};
        let fieldPlayers = [];
        let fieldPlayersAway = [];
        let goalkeeper = {};
        let goalkeeperAway = {};
        let gameAnimating = false;
        let isDragging = false, draggingPlayerIndex = null;
        let dragStart = { x: 0, y: 0 }, dragCurrent = { x: 0, y: 0 };
        let selectedHomeTeam = null, selectedAwayTeam = null;
        let matchTime = 180;
        let matchTimerInterval = null;
        let lastFrameTime = 0; // Do obliczenia delty czasu (opcjonalnie)

        // --- Stałe fizyki i gry ---
        const PLAYER_RADIUS = 16;
        const GOALKEEPER_RADIUS = 18;
        const BALL_RADIUS = 8;
        const FRICTION = 0.98;
        const BALL_FRICTION = 0.99;
        const WALL_RESTITUTION = 0.5;
        const PLAYER_RESTITUTION = 0.5; // Zmniejszona sprężystość gracz-piłka
        const PLAYER_PLAYER_RESTITUTION = 0.3; // Znacznie zmniejszona sprężystość gracz-gracz
        const PLAYER_COLLISION_FRICTION = 0.95; // Tarcie przy kolizjach gracz-gracz
        // === ZMIENIONA STAŁA SIŁY STRZAŁU ===
        const DRAG_IMPULSE_SCALE = 0.16; // Zwiększona siła naciągu
        const MAX_PLAYER_SPEED = 6; // Nieco szybsi gracze
        const MATCH_DURATION = 180; // 3 minuty
        // === LICZBA ITERACJI KOLIZJI ===
        const COLLISION_ITERATIONS = 3; // Sprawdzaj kolizje 3 razy na klatkę


        // --- Funkcje pomocnicze ---
        function formatTime(seconds) {
            let minutes = Math.floor(seconds / 60);
            let secs = seconds % 60;
            return minutes + ":" + (secs < 10 ? "0" : "") + secs;
        }

        function updateScoreboard() {
             scoreboardEl.innerText = `${selectedHomeTeam || 'DOM'} ${score.home} : ${score.away} ${selectedAwayTeam || 'GOŚĆ'}`;
        }

        function updateTimerDisplay() {
          matchTimerEl.innerText = "Czas: " + formatTime(matchTime);
        }

        // --- Logika Timera ---
        function startTimer() {
          stopTimer(); // Zatrzymaj poprzedni, jeśli istnieje
          matchTime = MATCH_DURATION;
          updateTimerDisplay();
          matchTimerInterval = setInterval(() => {
            if (!gameAnimating) return; // Pauzuj timer jeśli gra nieaktywna
            matchTime--;
            updateTimerDisplay();
            if (matchTime <= 0) {
              gameOver();
            }
          }, 1000);
        }

        function stopTimer() {
          clearInterval(matchTimerInterval);
          matchTimerInterval = null;
        }

        // --- Koniec gry i Reset ---
        function gameOver() {
          stopTimer();
          gameAnimating = false;
          if (backgroundMusic) {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
          }
          // Opóźnienie alertu, aby ostatnia klatka się wyrenderowała
          setTimeout(() => {
            alert(`Koniec meczu!\n\nWynik:\n${selectedHomeTeam} ${score.home} : ${score.away} ${selectedAwayTeam}`);
            resetGameToMenu();
          }, 100);
        }

        function resetGameToMenu() {
            gameScreen.classList.add("hidden");
            startScreen.classList.remove("hidden");

            // Reset stanu gry i UI
            selectedHomeTeam = null;
            selectedAwayTeam = null;
            selectedHomeTeamNameSpan.textContent = "";
            selectedAwayTeamNameSpan.textContent = "";
            startMatchFromSelectBtn.disabled = true;
            startMatchFromSelectBtn.textContent = "Wybierz obie drużyny";

            const teamOptions = document.querySelectorAll('#teamSelectScreen .team-option');
            teamOptions.forEach(opt => opt.classList.remove('selected'));

            // Usuń listenery canvas (ważne!)
            if (canvas) {
                canvas.removeEventListener("mousedown", canvasMouseDown);
                canvas.removeEventListener("mousemove", canvasMouseMove);
                canvas.removeEventListener("mouseup", canvasMouseUp);
                canvas.removeEventListener("mouseleave", canvasMouseUp);
                canvas.removeEventListener("touchstart", handleTouchStart, { passive: false });
                canvas.removeEventListener("touchmove", handleTouchMove, { passive: false });
                canvas.removeEventListener("touchend", handleTouchEnd);
                canvas.removeEventListener("touchcancel", handleTouchCancel);
            }
        }

        // --- Dane drużyn ---
        // (teamsData i getTeamColor bez zmian - skopiuj z poprzedniej wersji)
        const teamsData = {
          "Premier League": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/f2/Premier_League_Logo.svg", teams: [ { name: "Man United", logo: "https://upload.wikimedia.org/wikipedia/en/7/7a/Manchester_United_FC_crest.svg" }, { name: "Man City", logo: "https://upload.wikimedia.org/wikipedia/en/e/eb/Manchester_City_FC_badge.svg" }, { name: "Liverpool", logo: "https://upload.wikimedia.org/wikipedia/en/0/0c/Liverpool_FC.svg" }, { name: "Chelsea", logo: "https://upload.wikimedia.org/wikipedia/en/c/cc/Chelsea_FC.svg" }, { name: "Arsenal", logo: "https://upload.wikimedia.org/wikipedia/en/5/53/Arsenal_FC.svg" }, { name: "Tottenham", logo: "https://upload.wikimedia.org/wikipedia/en/b/b4/Tottenham_Hotspur.svg" } ] },
          "La Liga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/9/90/LaLiga.svg", teams: [ { name: "Real Madrid", logo: "https://upload.wikimedia.org/wikipedia/en/5/56/Real_Madrid_CF.svg" }, { name: "Barcelona", logo: "https://upload.wikimedia.org/wikipedia/en/4/47/FC_Barcelona_%28crest%29.svg" }, { name: "Atletico", logo: "https://brandlogos.net/wp-content/uploads/2021/09/atltico-madrid-logo.png" }, { name: "Sevilla", logo: "https://cdn.freebiesupply.com/logos/large/2x/sevilla-fc-logo-png-transparent.png" }, { name: "Valencia", logo: "https://brandlogos.net/wp-content/uploads/2014/10/valencia_cf-logo_brandlogos.net_iaffl-512x674.png" }, { name: "Villarreal", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Villarreal_CF_logo-en.svg/1200px-Villarreal_CF_logo-en.svg.png" } ] },
          "Serie A": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/d/d2/Serie_A_logo_(2019).svg", teams: [ { name: "Juventus", logo: "https://upload.wikimedia.org/wikipedia/commons/d/da/Juventus_Logo.png" }, { name: "Inter", logo: "https://upload.wikimedia.org/wikipedia/commons/0/05/FC_Internazionale_Milano_2021.svg" }, { name: "AC Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Logo_of_AC_Milan.svg/653px-Logo_of_AC_Milan.svg.png" }, { name: "Napoli", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/SSC_Neapel.svg/1200px-SSC_Neapel.svg.png" }, { name: "AS Roma", logo: "https://upload.wikimedia.org/wikipedia/sco/7/7d/AS_Roma%27s_logo_from_2017.png" }, { name: "Lazio", logo: "https://static.cdnlogo.com/logos/s/89/ss-lazio.png" } ] },
          "Bundesliga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/commons/d/df/Bundesliga_logo_(2017).svg", teams: [ { name: "Bayern", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/FC_Bayern_M%C3%BCnchen_logo_(2017).svg/2048px-FC_Bayern_M%C3%BCnchen_logo_(2017).svg.png" }, { name: "Dortmund", logo: "https://upload.wikimedia.org/wikipedia/commons/7/74/Borussia_Dortmund.png" }, { name: "RB Leipzig", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/0/04/RB_Leipzig_2014_logo.svg/1200px-RB_Leipzig_2014_logo.svg.png" }, { name: "Leverkusen", logo: "https://cdn.freebiesupply.com/logos/large/2x/bayer-leverkusen-logo-png-transparent.png" }, { name: "Frankfurt", logo: "https://logodownload.org/wp-content/uploads/2019/11/eintracht-frankfurt-logo.png" }, { name: "Gladbach", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Borussia_M%C3%B6nchengladbach_logo.svg/1200px-Borussia_M%C3%B6nchengladbach_logo.svg.png" } ] },
          "Ligue 1": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/fd/Ligue_1.svg", teams: [ { name: "PSG", logo: "https://logos-world.net/wp-content/uploads/2020/07/PSG-Logo.png" }, { name: "Marseille", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Olympique_Marseille_logo.svg/1582px-Olympique_Marseille_logo.svg.png" }, { name: "Lyon", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/1/1c/Olympique_Lyonnais_logo.svg/1200px-Olympique_Lyonnais_logo.svg.png" }, { name: "Monaco", logo: "https://logodownload.org/wp-content/uploads/2019/09/monaco-fc-logo-1.png" }, { name: "Lille", logo: "https://logodownload.org/wp-content/uploads/2019/09/lille-logo-1.png" }, { name: "Nice", logo: "https://1000logos.net/wp-content/uploads/2020/09/Nice-logo.png" } ] }
        };
        function getTeamColor(teamName) { /* ... (skopiuj całą funkcję getTeamColor) ... */
             switch(teamName) {
                // Premier League
                case "Man United": return "#DA291C"; case "Man City": return "#6CABDD"; case "Liverpool": return "#C8102E"; case "Chelsea": return "#034694"; case "Arsenal": return "#EF0107"; case "Tottenham": return "#132257";
                // La Liga
                case "Real Madrid": return "#FEBE10"; case "Barcelona": return "#A50044"; case "Atletico": return "#CB3524"; case "Sevilla": return "#F40000"; case "Valencia": return "#F37021"; case "Villarreal": return "#F2E300";
                // Serie A
                case "Juventus": return "#CCCCCC"; case "Inter": return "#0068A8"; case "AC Milan": return "#FB090B"; case "Napoli": return "#12A0D7"; case "AS Roma": return "#8E1F2F"; case "Lazio": return "#87D8F7";
                // Bundesliga
                case "Bayern": return "#DC052D"; case "Dortmund": return "#FDE100"; case "RB Leipzig": return "#E6002F"; case "Leverkusen": return "#E32221"; case "Frankfurt": return "#E1000F"; case "Gladbach": return "#00A450";
                // Ligue 1
                case "PSG": return "#004170"; case "Marseille": return "#0098D4"; case "Lyon": return "#EB1D35"; case "Monaco": return "#EF3340"; case "Lille": return "#E01E5A"; case "Nice": return "#CC0000";
                default: return "#777777";
            }
        }


        // --- Inicjalizacja Gry ---
        function initGame() {
          canvas = document.getElementById("gameCanvas");
          if (!canvas) {
              console.error("Nie znaleziono elementu canvas!");
              return;
          }
          ctx = canvas.getContext("2d");

          // Reset canvas dimensions if needed (optional, based on CSS aspect-ratio)
          // const canvasWidth = canvas.clientWidth;
          // canvas.width = canvasWidth;
          // canvas.height = canvasWidth * (5/8); // Maintain aspect ratio

          ball = {
            x: canvas.width / 2, y: canvas.height / 2,
            radius: BALL_RADIUS, vx: 0, vy: 0, color: "white"
          };

          let homeColor = getTeamColor(selectedHomeTeam);
          let awayColor = getTeamColor(selectedAwayTeam);

          // Formacja 2-1 (3 graczy pola)
          fieldPlayers = [
            { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
            { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
            { x: canvas.width * 0.38, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Lekko wysunięty
          ];
          fieldPlayersAway = [
            { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
            { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
            { x: canvas.width * 0.62, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Lekko wysunięty
          ];
          goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor };
          goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor };

          score = { home: 0, away: 0 };
          updateScoreboard(); // Zaktualizuj tablicę na starcie
          lastFrameTime = performance.now(); // Do delty czasu
        }

        // --- Rysowanie ---
        function drawField() { /* ... (bez zmian - skopiuj) ... */
            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineWidth = 2;
            const margin = 5;
            ctx.strokeRect(margin, margin, canvas.width - 2 * margin, canvas.height - 2 * margin);
            ctx.beginPath(); ctx.moveTo(canvas.width/2, margin); ctx.lineTo(canvas.width/2, canvas.height - margin); ctx.stroke();
            ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, 60, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, 3, 0, Math.PI * 2); ctx.fillStyle = "rgba(255, 255, 255, 0.6)"; ctx.fill();
            const goalWidth = 8; const goalHeight = 100; const goalY = canvas.height/2 - goalHeight/2;
            ctx.fillStyle = "#DDDDDD";
            ctx.fillRect(margin - goalWidth, goalY, goalWidth, goalHeight);
            ctx.fillRect(canvas.width - margin, goalY, goalWidth, goalHeight);
            const penaltyAreaWidth = canvas.width * 0.18; const penaltyAreaHeight = canvas.height * 0.45; const penaltyAreaY = canvas.height/2 - penaltyAreaHeight/2;
            ctx.strokeRect(margin, penaltyAreaY, penaltyAreaWidth, penaltyAreaHeight);
            ctx.strokeRect(canvas.width - margin - penaltyAreaWidth, penaltyAreaY, penaltyAreaWidth, penaltyAreaHeight);
            const goalAreaWidth = canvas.width * 0.07; const goalAreaHeight = canvas.height * 0.2; const goalAreaY = canvas.height/2 - goalAreaHeight/2;
            ctx.strokeRect(margin, goalAreaY, goalAreaWidth, goalAreaHeight);
            ctx.strokeRect(canvas.width - margin - goalAreaWidth, goalAreaY, goalAreaWidth, goalAreaHeight);
        }
        function drawGameObjects() { /* ... (bez zmian - skopiuj) ... */
           ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fillStyle = ball.color; ctx.fill();
           ctx.beginPath(); ctx.ellipse(ball.x, ball.y + ball.radius * 0.8, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.fill(); ctx.closePath();
           const drawPlayer = (player, outlineColor) => {
               ctx.beginPath(); ctx.ellipse(player.x, player.y + player.radius * 0.8, player.radius * 0.8, player.radius * 0.3, 0, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.fill();
               ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2); ctx.fillStyle = player.color; ctx.fill();
               ctx.strokeStyle = outlineColor; ctx.lineWidth = 2; ctx.stroke(); ctx.closePath();
           };
           fieldPlayers.forEach(player => drawPlayer(player, "white")); drawPlayer(goalkeeper, "white");
           fieldPlayersAway.forEach(player => drawPlayer(player, "black")); drawPlayer(goalkeeperAway, "black");
           if (isDragging && draggingPlayerIndex !== null && dragStart && dragCurrent) {
               let playerDragged = (draggingPlayerIndex === -1) ? goalkeeper : fieldPlayers[draggingPlayerIndex];
               if (playerDragged) {
                   ctx.save(); ctx.beginPath(); ctx.moveTo(playerDragged.x, playerDragged.y);
                   let targetX = playerDragged.x - (dragCurrent.x - dragStart.x); let targetY = playerDragged.y - (dragCurrent.y - dragStart.y);
                   let dx = targetX - playerDragged.x; let dy = targetY - playerDragged.y; let length = Math.hypot(dx, dy);
                   const visualMaxLength = 80;
                   if (length > visualMaxLength) { targetX = playerDragged.x + (dx / length) * visualMaxLength; targetY = playerDragged.y + (dy / length) * visualMaxLength; length = visualMaxLength; }
                   let strengthRatio = Math.min(length / visualMaxLength, 1); let red = Math.floor(255 * strengthRatio); let green = Math.floor(255 * (1 - strengthRatio));
                   ctx.strokeStyle = `rgb(${red}, ${green}, 0)`; ctx.lineWidth = 1 + 3 * strengthRatio; ctx.setLineDash([6, 4]);
                   ctx.lineTo(targetX, targetY); ctx.stroke();
                   if (length > 10) {
                       let angle = Math.atan2(targetY - playerDragged.y, targetX - playerDragged.x);
                       ctx.lineTo(targetX - 10 * Math.cos(angle - Math.PI / 6), targetY - 10 * Math.sin(angle - Math.PI / 6)); ctx.moveTo(targetX, targetY);
                       ctx.lineTo(targetX - 10 * Math.cos(angle + Math.PI / 6), targetY - 10 * Math.sin(angle + Math.PI / 6)); ctx.stroke();
                   }
                   ctx.restore();
               }
           }
        }

        // --- Aktualizacja Pozycji ---
        function updatePositions() { /* ... (bez zmian - skopiuj) ... */
             const margin = 5;
             const updatePlayer = (player) => {
                player.x += player.vx; player.y += player.vy;
                const speed = Math.hypot(player.vx, player.vy);
                if (speed > MAX_PLAYER_SPEED) { player.vx = (player.vx / speed) * MAX_PLAYER_SPEED; player.vy = (player.vy / speed) * MAX_PLAYER_SPEED; }
                if (player.x - player.radius < margin) { player.x = margin + player.radius; player.vx *= -WALL_RESTITUTION; }
                if (player.x + player.radius > canvas.width - margin) { player.x = canvas.width - margin - player.radius; player.vx *= -WALL_RESTITUTION; }
                if (player.y - player.radius < margin) { player.y = margin + player.radius; player.vy *= -WALL_RESTITUTION; }
                if (player.y + player.radius > canvas.height - margin) { player.y = canvas.height - margin - player.radius; player.vy *= -WALL_RESTITUTION; }
                player.vx *= FRICTION; player.vy *= FRICTION;
             };
             fieldPlayers.forEach(updatePlayer); fieldPlayersAway.forEach(updatePlayer);
             const updateGoalkeeper = (gk, targetX) => {
                let targetY_GK = ball.y;
                const penaltyAreaHeight = canvas.height * 0.45; const minY_GK = canvas.height / 2 - penaltyAreaHeight / 2 + gk.radius + margin; const maxY_GK = canvas.height / 2 + penaltyAreaHeight / 2 - gk.radius - margin;
                targetY_GK = Math.max(minY_GK, Math.min(maxY_GK, targetY_GK)); let dyGK = targetY_GK - gk.y; let speedGK = 2.0; // Szybszy GK
                if (Math.abs(dyGK) > 1) { gk.vy = Math.sign(dyGK) * speedGK; } else { gk.vy = 0; }
                gk.x = targetX; gk.y += gk.vy; gk.vy *= FRICTION; gk.y = Math.max(margin + gk.radius, Math.min(canvas.height - margin - gk.radius, gk.y));
                if (targetX < canvas.width / 2) { gk.x = Math.max(targetX, gk.x); } else { gk.x = Math.min(targetX, gk.x); }
             };
             updateGoalkeeper(goalkeeper, 40); updateGoalkeeper(goalkeeperAway, canvas.width - 40);
             ball.x += ball.dx; ball.y += ball.dy; ball.dx *= FRICTION * BALL_FRICTION; ball.dy *= FRICTION * BALL_FRICTION;
             if (ball.y - ball.radius < margin) { ball.y = margin + ball.radius; ball.dy *= -WALL_RESTITUTION; }
             if (ball.y + ball.radius > canvas.height - margin) { ball.y = canvas.height - margin - ball.radius; ball.dy *= -WALL_RESTITUTION; }
             const goalHeight = 100; const goalTop = canvas.height/2 - goalHeight/2; const goalBottom = canvas.height/2 + goalHeight/2; let goalScored = false;
             if (ball.x - ball.radius < margin) { if (ball.y > goalTop && ball.y < goalBottom) { score.away++; goalScored = true; resetPositionsAfterGoal(true); } else { ball.x = margin + ball.radius; ball.dx *= -WALL_RESTITUTION; } }
             if (ball.x + ball.radius > canvas.width - margin) { if (ball.y > goalTop && ball.y < goalBottom) { score.home++; goalScored = true; resetPositionsAfterGoal(false); } else { ball.x = canvas.width - margin - ball.radius; ball.dx *= -WALL_RESTITUTION; } }
             if (goalScored) { updateScoreboard(); }
        }

        function resetPositionsAfterGoal(homeTeamScored) { /* ... (bez zmian - skopiuj) ... */
           ball.x = canvas.width / 2; ball.y = canvas.height / 2; ball.dx = 0; ball.dy = 0;
           let homeColor = getTeamColor(selectedHomeTeam); let awayColor = getTeamColor(selectedAwayTeam);
           fieldPlayers = [ { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, { x: canvas.width * 0.38, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor } ];
           fieldPlayersAway = [ { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, { x: canvas.width * 0.62, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor } ];
           goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor }; goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor };
        }

        // --- Kolizje ---
        function circleCollision(c1, c2) { /* ... (bez zmian - skopiuj) ... */
          const dx = c1.x - c2.x; const dy = c1.y - c2.y; const distance = Math.hypot(dx, dy); const radiiSum = c1.radius + c2.radius; return distance < radiiSum;
        }

        function resolveCollision(c1, c2, isPlayerPlayerCollision = false) {
            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            let distance = Math.hypot(dx, dy);

            const epsilon = 0.01;
            if (distance < epsilon) {
                 distance = epsilon;
                 const randomAngle = Math.random() * Math.PI * 2;
                 const adjust = epsilon / 2;
                 if (!c1.isStatic) { c1.x -= Math.cos(randomAngle) * adjust; c1.y -= Math.sin(randomAngle) * adjust; }
                 if (!c2.isStatic) { c2.x += Math.cos(randomAngle) * adjust; c2.y += Math.sin(randomAngle) * adjust; }
            }

            const radiiSum = c1.radius + c2.radius;
            const overlap = radiiSum - distance;

            if (overlap > 0) {
                // Rozsunięcie
                const adjustFactor = overlap / distance / 2;
                let adjustX = dx * adjustFactor;
                let adjustY = dy * adjustFactor;

                // === ZMIENIONO OGRANICZENIE KOREKTY ===
                const MAX_POSITION_CORRECTION = 5; // Użyj stałej wartości, np. 5 pikseli
                const correctionMagnitude = Math.hypot(adjustX, adjustY);
                if (correctionMagnitude > MAX_POSITION_CORRECTION) {
                    const scale = MAX_POSITION_CORRECTION / correctionMagnitude;
                    adjustX *= scale;
                    adjustY *= scale;
                }

                if (!c1.isStatic) { c1.x -= adjustX; c1.y -= adjustY; }
                if (!c2.isStatic) { c2.x += adjustX; c2.y += adjustY; }

                // Wymiana pędu
                const angle = Math.atan2(dy, dx);
                const sine = Math.sin(angle);
                const cosine = Math.cos(angle);

                let v1 = { x: c1.vx * cosine + c1.vy * sine, y: c1.vy * cosine - c1.vx * sine };
                let v2 = { x: c2.vx * cosine + c2.vy * sine, y: c2.vy * cosine - c2.vx * sine };

                // === ZMIENIONO RESTYTUCJĘ ===
                const restitution = isPlayerPlayerCollision ? PLAYER_PLAYER_RESTITUTION : PLAYER_RESTITUTION;
                const collisionFriction = isPlayerPlayerCollision ? PLAYER_COLLISION_FRICTION : 1.0;

                const m1 = c1.radius * c1.radius;
                const m2 = c2.radius * c2.radius;
                const totalMass = m1 + m2;

                let vFinal1_x = ((m1 - m2 * restitution) * v1.x + (m2 + m2 * restitution) * v2.x) / totalMass;
                let vFinal2_x = ((m1 + m1 * restitution) * v1.x + (m2 - m1 * restitution) * v2.x) / totalMass;

                v1.y *= collisionFriction;
                v2.y *= collisionFriction;

                // Sprawdzenie NaN przed przypisaniem (dodatkowe zabezpieczenie)
                 if (!isNaN(vFinal1_x) && !isNaN(v1.y)) {
                    c1.vx = (vFinal1_x * cosine - v1.y * sine);
                    c1.vy = (v1.y * cosine + vFinal1_x * sine);
                 }
                 if (!isNaN(vFinal2_x) && !isNaN(v2.y)) {
                     c2.vx = (vFinal2_x * cosine - v2.y * sine);
                     c2.vy = (v2.y * cosine + vFinal2_x * sine);
                 }
            }
        }

        // === ZMIENIONA FUNKCJA checkCollisions (dodano iteracje) ===
        function checkCollisions() {
            const allPlayers = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway];
            const allObjects = [...allPlayers, ball]; // Wszystkie ruchome obiekty

            for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) { // Pętla iteracji
                // Kolizje Gracz-Piłka
                allPlayers.forEach(player => {
                     if (circleCollision(player, ball)) {
                        resolveCollision(player, ball, false);
                     }
                });

                 // Kolizje Gracz-Gracz
                for (let i = 0; i < allPlayers.length; i++) {
                    for (let j = i + 1; j < allPlayers.length; j++) {
                        if (circleCollision(allPlayers[i], allPlayers[j])) {
                            resolveCollision(allPlayers[i], allPlayers[j], true);
                        }
                    }
                }
            } // Koniec pętli iteracji
        }


        // --- AI ---
        function aiMove() { /* ... (bez zmian - skopiuj) ... */
            const aiSpeed = 1.3; const shootingRange = canvas.width * 0.4; const optimalDistanceFactor = 4; const passProbability = 0.08; const goalTargetX = 40 + GOALKEEPER_RADIUS;
            fieldPlayersAway.forEach((player, index) => {
                let dxToBall = ball.x - player.x; let dyToBall = ball.y - player.y; let distToBall = Math.hypot(dxToBall, dyToBall) || 1;
                let dxToGoal = goalTargetX - player.x; let dyToGoal = canvas.height / 2 - player.y; let distToGoal = Math.hypot(dxToGoal, dyToGoal);
                let isClosestToBall = true;
                for(let otherPlayer of fieldPlayersAway) { if (otherPlayer !== player && Math.hypot(ball.x - otherPlayer.x, ball.y - otherPlayer.y) < distToBall) { isClosestToBall = false; break; } }
                if (!isClosestToBall && player.x > canvas.width / 2) {
                    let targetX = canvas.width * 0.3 + Math.random() * canvas.width * 0.2; let targetY = canvas.height * 0.2 + Math.random() * canvas.height * 0.6;
                    let dxToPos = targetX - player.x; let dyToPos = targetY - player.y; let distToPos = Math.hypot(dxToPos, dyToPos) || 1;
                    player.vx += (dxToPos / distToPos) * aiSpeed * 0.5; player.vy += (dyToPos / distToPos) * aiSpeed * 0.5; return;
                }
                if (player.x > canvas.width * 0.55 && distToGoal < shootingRange && distToBall < player.radius + ball.radius + 20) { // Zwiększony zasięg reakcji
                    if (Math.random() < passProbability) {
                        let bestPassTarget = null; let minPassDist = Infinity;
                        fieldPlayersAway.forEach(teammate => {
                            if (teammate !== player && teammate.x < player.x) { let dist = Math.hypot(teammate.x - player.x, teammate.y - player.y); if (dist < minPassDist && dist < canvas.width * 0.4) { minPassDist = dist; bestPassTarget = teammate; } } });
                        if (bestPassTarget) {
                            let passStrength = 3.5 + Math.random() * 1.5; let passAngle = Math.atan2(bestPassTarget.y - player.y, bestPassTarget.x - player.x);
                            ball.dx = Math.cos(passAngle) * passStrength; ball.dy = Math.sin(passAngle) * passStrength;
                            player.vx += Math.cos(passAngle) * passStrength * 0.1; player.vy += Math.sin(passAngle) * passStrength * 0.1; return;
                        }
                    }
                    let shootStrength = 5.0 + Math.random() * 2.5; // Mocniejszy strzał
                    let targetShootY = canvas.height / 2 + (Math.random() - 0.5) * (100 * 0.8); let shootAngle = Math.atan2(targetShootY - player.y, goalTargetX - player.x);
                    ball.dx = Math.cos(shootAngle) * shootStrength; ball.dy = Math.sin(shootAngle) * shootStrength;
                    player.vx += Math.cos(shootAngle) * shootStrength * 0.05; player.vy += Math.sin(shootAngle) * shootStrength * 0.05;
                } else {
                    let targetX = ball.x; let targetY = ball.y; let optimalDist = player.radius * optimalDistanceFactor;
                    if (distToBall > optimalDist) { player.vx += (dxToBall / distToBall) * aiSpeed * (Math.random() * 0.3 + 0.85); player.vy += (dyToBall / distToBall) * aiSpeed * (Math.random() * 0.3 + 0.85); }
                    else if (distToBall < optimalDist * 0.6 && player.x > canvas.width * 0.6) { player.vx -= (dxToBall / distToBall) * aiSpeed * 0.5; player.vy -= (dyToBall / distToBall) * aiSpeed * 0.5; }
                    else {
                        let angleToGoal = Math.atan2(canvas.height / 2 - ball.y, goalTargetX - ball.x); targetX = ball.x + Math.cos(angleToGoal + Math.PI) * optimalDist * 0.7; targetY = ball.y + Math.sin(angleToGoal + Math.PI) * optimalDist * 0.7;
                        let dxToTargetPos = targetX - player.x; let dyToTargetPos = targetY - player.y; let distToTargetPos = Math.hypot(dxToTargetPos, dyToTargetPos) || 1;
                        player.vx += (dxToTargetPos / distToTargetPos) * aiSpeed; player.vy += (dyToTargetPos / distToTargetPos) * aiSpeed;
                    }
                }
            });
        }

        // --- Główna Pętla Gry ---
        function gameLoop(currentTime) {
          if (!gameAnimating) return;

          // Delta time (opcjonalnie, dla płynniejszej fizyki niezależnej od FPS)
          // const deltaTime = (currentTime - lastFrameTime) / 1000; // Czas w sekundach
          // lastFrameTime = currentTime;
          // Można by mnożyć prędkości przez deltaTime w updatePositions, ale to komplikuje

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawField();

          if (!isDragging) { aiMove(); }
          updatePositions(/* deltaTime */); // Aktualizuj fizykę
          checkCollisions();       // Rozwiąż kolizje (wielokrotnie)

          drawGameObjects();       // Narysuj stan po fizyce

          requestAnimationFrame(gameLoop);
        }

        // --- Sterowanie ---
        // === ZMIENIONA FUNKCJA canvasMouseUp (mocniejszy strzał) ===
        function canvasMouseUp(e) {
          if (!isDragging || draggingPlayerIndex === null || !gameAnimating) return;

          let playerToMove = (draggingPlayerIndex === -1) ? goalkeeper : fieldPlayers[draggingPlayerIndex];
          if (!playerToMove) { // Dodatkowe zabezpieczenie
                isDragging = false; draggingPlayerIndex = null; return;
          }

          const dx = dragStart.x - dragCurrent.x;
          const dy = dragStart.y - dragCurrent.y;
          const dragDistance = Math.hypot(dx, dy);
          const minDragDistance = 5; // Mniejszy próg reakcji

          if (dragDistance > minDragDistance) {
              const maxEffectiveDrag = 180; // Zwiększono maksymalny efektywny naciąg
              const effectiveDrag = Math.min(dragDistance, maxEffectiveDrag);

              // === USUNIĘTO DZIELNIK, ZWIĘKSZONO SKALĘ ===
              const impulseMagnitude = effectiveDrag * DRAG_IMPULSE_SCALE;

              playerToMove.vx = (dx / dragDistance) * impulseMagnitude;
              playerToMove.vy = (dy / dragDistance) * impulseMagnitude;

              // === USUNIĘTO POCZĄTKOWE OGRANICZENIE PRĘDKOŚCI ===
              // Ograniczenie w updatePlayer powinno wystarczyć

          } else {
              playerToMove.vx = 0; playerToMove.vy = 0;
          }

          isDragging = false;
          draggingPlayerIndex = null;
          dragStart = { x: 0, y: 0 };
          dragCurrent = { x: 0, y: 0 };
        }

        function canvasMouseDown(e) { /* ... (bez zmian - skopiuj) ... */
          if (!gameAnimating) return; const rect = canvas.getBoundingClientRect();
          const clientX = e.clientX || (e.touches && e.touches[0].clientX); const clientY = e.clientY || (e.touches && e.touches[0].clientY);
          if (clientX === undefined || clientY === undefined) return; const mx = clientX - rect.left; const my = clientY - rect.top;
          draggingPlayerIndex = null; const gk = goalkeeper;
          if (Math.hypot(mx - gk.x, my - gk.y) < gk.radius + 15) { draggingPlayerIndex = -1; } // Zwiększony obszar GK
           else { for (let i = 0; i < fieldPlayers.length; i++) { const p = fieldPlayers[i]; if (Math.hypot(mx - p.x, my - p.y) < p.radius + 10) { draggingPlayerIndex = i; break; } } }
          if (draggingPlayerIndex !== null) {
              isDragging = true; let playerDragged = (draggingPlayerIndex === -1) ? goalkeeper : fieldPlayers[draggingPlayerIndex];
              dragStart = { x: mx, y: my }; dragCurrent = { x: mx, y: my };
              // playerDragged.vx = 0; playerDragged.vy = 0; // Opcjonalnie zatrzymaj
          }
        }
        function canvasMouseMove(e) { /* ... (bez zmian - skopiuj) ... */
          if (!isDragging || !gameAnimating) return; const rect = canvas.getBoundingClientRect();
          const clientX = e.clientX || (e.touches && e.touches[0].clientX); const clientY = e.clientY || (e.touches && e.touches[0].clientY);
          if (clientX === undefined || clientY === undefined) return; dragCurrent.x = clientX - rect.left; dragCurrent.y = clientY - rect.top;
        }

        // Obsługa dotyku (wrappery dla funkcji myszy)
        function handleTouchStart(e) { if (e.touches.length === 1) { e.preventDefault(); canvasMouseDown(e); } }
        function handleTouchMove(e) { if (e.touches.length === 1) { e.preventDefault(); canvasMouseMove(e); } }
        function handleTouchEnd(e) { e.preventDefault(); canvasMouseUp(e); }
        function handleTouchCancel(e) { isDragging = false; draggingPlayerIndex = null; }


        // --- UI i Wybór Drużyn ---
        function populateTeamSelections() { /* ... (bez zmian - skopiuj) ... */
             homeContainer.innerHTML = ""; awayContainer.innerHTML = ""; selectedHomeTeam = null; selectedAwayTeam = null; startMatchFromSelectBtn.disabled = true; selectedHomeTeamNameSpan.textContent = ""; selectedAwayTeamNameSpan.textContent = "";
             const checkStartButton = () => {
                if (selectedHomeTeam && selectedAwayTeam && selectedHomeTeam !== selectedAwayTeam) { startMatchFromSelectBtn.disabled = false; startMatchFromSelectBtn.textContent = "Rozpocznij Mecz"; }
                 else if (selectedHomeTeam && selectedAwayTeam && selectedHomeTeam === selectedAwayTeam) { startMatchFromSelectBtn.disabled = true; startMatchFromSelectBtn.textContent = "Wybierz różne drużyny"; }
                 else { startMatchFromSelectBtn.disabled = true; startMatchFromSelectBtn.textContent = "Wybierz obie drużyny"; } };
             const createTeamOption = (team, containerType) => {
                let teamDiv = document.createElement("div"); teamDiv.className = "team-option"; teamDiv.dataset.team = team.name; teamDiv.title = team.name; teamDiv.innerHTML = `<img src="${team.logo}" alt="${team.name}" loading="lazy" /><p>${team.name}</p>`;
                teamDiv.addEventListener("click", function () {
                    const containerElement = containerType === 'home' ? homeContainer : awayContainer; const isSelected = this.classList.contains("selected");
                    Array.from(containerElement.querySelectorAll('.team-option')).forEach(el => el.classList.remove("selected"));
                    if (!isSelected) {
                        this.classList.add("selected");
                        if (containerType === 'home') { selectedHomeTeam = team.name; selectedHomeTeamNameSpan.textContent = `(${team.name})`; } else { selectedAwayTeam = team.name; selectedAwayTeamNameSpan.textContent = `(${team.name})`; }
                    } else { if (containerType === 'home') { selectedHomeTeam = null; selectedHomeTeamNameSpan.textContent = ""; } else { selectedAwayTeam = null; selectedAwayTeamNameSpan.textContent = ""; } }
                    checkStartButton(); }); return teamDiv; };
             for (let league in teamsData) {
                let leagueHeaderHome = document.createElement("div"); leagueHeaderHome.className = "league-header"; leagueHeaderHome.innerHTML = `<img src="${teamsData[league].leagueLogo}" alt="${league}" loading="lazy"> ${league}`; homeContainer.appendChild(leagueHeaderHome);
                let teamRowHome = document.createElement('div'); teamRowHome.className = 'team-row'; teamsData[league].teams.forEach(team => { teamRowHome.appendChild(createTeamOption(team, 'home')); }); homeContainer.appendChild(teamRowHome);
                let leagueHeaderAway = document.createElement("div"); leagueHeaderAway.className = "league-header"; leagueHeaderAway.innerHTML = `<img src="${teamsData[league].leagueLogo}" alt="${league}" loading="lazy"> ${league}`; awayContainer.appendChild(leagueHeaderAway);
                let teamRowAway = document.createElement('div'); teamRowAway.className = 'team-row'; teamsData[league].teams.forEach(team => { teamRowAway.appendChild(createTeamOption(team, 'away')); }); awayContainer.appendChild(teamRowAway);
             } checkStartButton();
        }

        // --- Główny Setup ---
        document.addEventListener("DOMContentLoaded", () => {
          startMatchBtn.addEventListener("click", () => {
            startScreen.classList.add("hidden");
            teamSelectScreen.classList.remove("hidden");
            populateTeamSelections();
          });

          startMatchFromSelectBtn.addEventListener("click", () => {
            if (startMatchFromSelectBtn.disabled) return; // Nie rób nic, jeśli nieaktywny

            console.log("Rozpoczynanie meczu:", selectedHomeTeam, "-", selectedAwayTeam);
            teamSelectScreen.classList.add("hidden");
            gameScreen.classList.remove("hidden");

            initGame(); // Musi być wywołane przed dodaniem listenerów do canvas!

            // Dodaj listenery myszy i dotyku
            canvas.addEventListener("mousedown", canvasMouseDown);
            canvas.addEventListener("mousemove", canvasMouseMove);
            canvas.addEventListener("mouseup", canvasMouseUp);
            canvas.addEventListener("mouseleave", canvasMouseUp);
            canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
            canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
            canvas.addEventListener("touchend", handleTouchEnd);
            canvas.addEventListener("touchcancel", handleTouchCancel);


            startTimer();
            gameAnimating = true;

            if (backgroundMusic) {
               var playPromise = backgroundMusic.play();
               if (playPromise !== undefined) {
                 playPromise.catch(error => { console.warn("Autoodtwarzanie muzyki nie powiodło się:", error); });
               }
            } else { console.warn("Nie znaleziono elementu audio #backgroundMusic"); }

            requestAnimationFrame(gameLoop);
          });

          backToStartBtn.addEventListener("click", () => {
            gameAnimating = false;
            stopTimer();
            if (backgroundMusic) { backgroundMusic.pause(); backgroundMusic.currentTime = 0; }
            resetGameToMenu();
          });

        }); // Koniec DOMContentLoaded

      })(); // Koniec IIFE
    </script>
  </body>
</html>
