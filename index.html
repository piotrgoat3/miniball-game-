<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MiniSoccer - Szybki Mecz</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
        rel="stylesheet"
    />
    <style>
        /* --- STYLE CSS --- */
         :root { /* Domyślne rozmiary */ --font-size-h1: 56px; --font-size-h2: 40px; --font-size-h3: 28px; --font-size-button: 20px; --font-size-button-padding: 15px 30px; --font-size-small-button: 18px; --font-size-small-button-padding: 10px 20px; --font-size-team-option: 1rem; --font-size-scoreboard: 28px; --font-size-timer: 20px; }
         body {
             font-family: "Nunito", sans-serif;
             /* === ZMIANA: Usunięto statyczne tło Anfield, dodano domyślny kolor === */
             background-color: #1a1a1a; /* Domyślne ciemne tło dla menu */
             /* background: url("anfield_top_down.jpg") no-repeat center center fixed; */ /* USUNIĘTE */
             background-size: cover;
             background-position: center center;
             background-attachment: fixed;
             margin: 0; padding: 0; text-align: center; color: #fff; font-size: var(--font-size-team-option); transition: font-size 0.3s ease; overflow: hidden;
         }
         /* === ZMIANA: Przyciemnienie overlay trochę mocniejsze dla lepszego kontrastu na domyślnym tle === */
         body::before { content: ""; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); /* Slightly darker overlay */ z-index: -1; }
         .hidden { display: none !important; }
         body.font-size-small { --font-size-h1: 48px; --font-size-h2: 34px; --font-size-h3: 24px; --font-size-button: 18px; --font-size-button-padding: 12px 25px; --font-size-small-button: 16px; --font-size-small-button-padding: 8px 16px; --font-size-team-option: 0.9rem; --font-size-scoreboard: 24px; --font-size-timer: 18px; }
         body.font-size-medium {}
         body.font-size-large { --font-size-h1: 64px; --font-size-h2: 46px; --font-size-h3: 32px; --font-size-button: 22px; --font-size-button-padding: 18px 35px; --font-size-small-button: 20px; --font-size-small-button-padding: 12px 25px; --font-size-team-option: 1.1rem; --font-size-scoreboard: 32px; --font-size-timer: 22px; }
         #startScreen { padding: 40px 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; box-sizing: border-box; }
         #startScreen h1 { font-size: var(--font-size-h1); margin-bottom: 30px; text-shadow: 2px 2px 5px rgba(0,0,0,0.3); }
         #startScreen button { font-size: var(--font-size-button); padding: var(--font-size-button-padding); margin: 10px; border: none; border-radius: 10px; background-color: rgba(255,255,255,0.85); cursor: pointer; color: #333; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); transition: all 0.3s ease; min-width: 200px; }
         #startScreen button:hover { background-color: #fff; transform: scale(1.05); box-shadow: 0px 5px 15px rgba(0,0,0,0.3); }
         .start-options { margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: center;}
         .start-options button { font-size: var(--font-size-small-button); padding: var(--font-size-small-button-padding); background-color: rgba(255,255,255,0.7); min-width: 150px; }
         .start-options button:hover { background-color: #eee; }
         #teamSelectScreen { padding: 30px 15px; box-sizing: border-box; max-height: 100vh; overflow-y: auto;}
         #teamSelectScreen h2 { font-size: var(--font-size-h2); margin-bottom: 15px; text-shadow: 1px 1px 4px rgba(0,0,0,0.3); }
         .team-section { margin: 20px auto; max-width: 90%; text-align: left; }
         .team-section h3 { font-size: var(--font-size-h3); margin-bottom: 10px; padding-left: 10px; }
         .team-container { display: flex; gap: 15px; overflow-x: auto; padding: 10px 5px; scrollbar-width: thin; scrollbar-color: #ffd700 rgba(0,0,0,0.2); min-height: 160px; }
         .team-container::-webkit-scrollbar { height: 10px; background: rgba(0,0,0,0.1); border-radius: 5px; }
         .team-container::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 5px; border: 2px solid rgba(0,0,0,0.1); }
         .team-option { cursor: pointer; text-align: center; border: 3px solid rgba(255,255,255,0.5); border-radius: 12px; width: 130px; padding: 10px; transition: all 0.2s ease; flex: 0 0 auto; font-size: calc(var(--font-size-team-option) * 0.9); background-color: rgba(0,0,0, 0.2); display: flex; flex-direction: column; justify-content: space-between; }
         .team-option p { margin: 5px 0 0 0; word-wrap: break-word; }
         .team-option.selected { border-color: #ffd700; transform: scale(1.08); background-color: rgba(255,255,255,0.2); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
         .team-option img { width: 70px; height: 70px; display: block; margin: 0 auto 8px; object-fit: contain; }
         .league-header { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; padding-left: 10px; }
         .league-header img { width: 25px; height: 25px; }
         #goToStadiumSelectBtn { /* Changed ID */ font-size: var(--font-size-button); padding: var(--font-size-button-padding); margin-top: 25px; cursor: pointer; background-color: rgba(60, 150, 220, 0.9); /* Blueish color for "Next" */ border: none; border-radius: 12px; transition: all 0.3s ease; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); color: white; }
         #goToStadiumSelectBtn:hover { background-color: rgba(50, 130, 200, 1); transform: scale(1.05); box-shadow: 0px 5px 15px rgba(0,0,0,0.3); }

         /* === NEW STYLES for Stadium Selection === */
         #stadiumSelectScreen { padding: 30px 15px; box-sizing: border-box; max-height: 100vh; overflow-y: auto; text-align: center; }
         #stadiumSelectScreen h2 { font-size: var(--font-size-h2); margin-bottom: 20px; text-shadow: 1px 1px 4px rgba(0,0,0,0.3); }
         .stadium-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; padding: 10px; margin-bottom: 25px; }
         .stadium-option { cursor: pointer; text-align: center; border: 3px solid rgba(255,255,255,0.5); border-radius: 12px; width: 250px; /* Wider option */ padding: 15px; transition: all 0.2s ease; background-color: rgba(0,0,0, 0.3); display: flex; flex-direction: column; align-items: center; }
         .stadium-option img { width: 100%; height: 140px; /* Fixed height for consistency */ object-fit: cover; border-radius: 8px; margin-bottom: 10px; }
         .stadium-option p { margin: 5px 0 0 0; font-size: calc(var(--font-size-team-option) * 1.1); font-weight: bold; }
         .stadium-option.selected { border-color: #ffd700; transform: scale(1.05); background-color: rgba(255,255,255,0.2); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
         #startMatchFromStadiumBtn { font-size: var(--font-size-button); padding: var(--font-size-button-padding); margin-top: 10px; cursor: pointer; background-color: rgba(90, 180, 90, 0.9); border: none; border-radius: 12px; transition: all 0.3s ease; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); color: white; }
         #startMatchFromStadiumBtn:hover:not(:disabled) { background-color: rgba(70, 160, 70, 1); transform: scale(1.05); }
         #startMatchFromStadiumBtn:disabled { background-color: #aaaaaa; cursor: not-allowed; opacity: 0.7; }
         .button-group { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
         .close-btn { /* General style for back/close buttons */ font-size: var(--font-size-small-button); padding: var(--font-size-small-button-padding); background: #dc3545; border: none; border-radius: 8px; transition: background 0.3s; box-shadow: 0px 3px 6px rgba(0,0,0,0.2); cursor: pointer; color: white; min-width: 120px; }
         .close-btn:hover { background: #c82333; }
        /* === END OF NEW STYLES === */

         #gameScreen { padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; height: 100vh; }
         #scoreboardContainer { margin-bottom: 8px; background: rgba(0,0,0,0.5); padding: 4px 12px; border-radius: 8px; }
         #scoreboard { font-size: calc(var(--font-size-scoreboard) * 0.9); font-weight: bold; margin: 0; }
         #matchTimer { font-size: calc(var(--font-size-timer) * 0.9); margin-top: 2px; color: #eee; }
         canvas {
             /* === ZMIANA: Domyślny kolor tła canvas (może być nadpisany przez drawField) === */
             background-color: #2A9D8F;
             border: 3px solid #fff; border-radius: 10px; display: block; margin: 0 auto; box-shadow: 0px 6px 12px rgba(0,0,0,0.3); cursor: grab;
             max-width: 96%; max-height: calc(100vh - 130px);
             /* === ZMIANA: Aktualizacja aspect-ratio do nowych wymiarów (640/400 = 8/5) === */
             aspect-ratio: 640 / 400;
             width: auto; height: auto;
         }
         canvas:active { cursor: grabbing; }
         #backToStartBtn { font-size: var(--font-size-small-button); padding: 8px 16px; margin-top: 10px; cursor: pointer; background: rgba(200, 80, 80, 0.9); border: none; border-radius: 8px; transition: background 0.3s; box-shadow: 0px 3px 6px rgba(0,0,0,0.2); color: white; }
         #backToStartBtn:hover { background: rgba(180, 60, 60, 1); }
         .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 100; animation: fadeIn 0.3s ease-out; }
         @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
         .modal-content { background: #f8f9fa; padding: 25px; width: 90%; max-width: 450px; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.2); color: #343a40; max-height: 80vh; overflow-y: auto; }
         .modal-content h2 { margin-top: 0; font-size: calc(var(--font-size-h3) * 1.1); color: #007bff; }
         .modal-content h3 { font-size: calc(var(--font-size-h3) * 0.9); color: #6c757d; margin-top: 15px;}
         .modal-content p { font-size: var(--font-size-team-option); line-height: 1.5; }
         .modal-content button { font-size: var(--font-size-small-button); padding: 10px 18px; background: #007bff; border: none; border-radius: 6px; margin-top: 10px; margin-right: 8px; transition: background 0.3s, transform 0.2s; box-shadow: 0px 2px 5px rgba(0,0,0,0.15); cursor: pointer; color: white; }
         .modal-content button:hover { background: #0056b3; transform: translateY(-1px); }
         .modal-content button.close-btn { background: #dc3545; } /* Ensure modal close buttons use this style */
         .modal-content button.close-btn:hover { background: #c82333; }
         .modal-content button.active-size { background: #28a745; box-shadow: inset 0px 2px 4px rgba(0,0,0,0.2); }
         .modal-content button.active-size:hover { background: #218838; }
         input, select { border: 1px solid #ced4da; border-radius: 6px; padding: 10px; margin: 8px 0; width: calc(100% - 22px); box-sizing: border-box; font-size: var(--font-size-team-option); background-color: #fff; }
         input:focus, select:focus { border-color: #80bdff; outline: 0; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); }
         #playerList { max-height: 250px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #007bff #e9ecef; margin-bottom: 15px; border: 1px solid #dee2e6; padding: 10px; border-radius: 6px; background-color: #fff; }
         #playerList::-webkit-scrollbar { width: 8px; }
         #playerList::-webkit-scrollbar-thumb { background: #007bff; border-radius: 5px; }
         #playerList::-webkit-scrollbar-track { background: #e9ecef; }
         #addPlayerForm { margin-top: 15px; }
         #addPlayerForm button { margin-top: 10px; margin-right: 0; background-color: #28a745; }
         #addPlayerForm button:hover { background-color: #218838; }
         .font-size-options { margin-top: 15px; margin-bottom: 20px; text-align: center;}
         .font-size-options button { margin: 5px; }
    </style>
</head>
<body class="font-size-medium">
    <!-- EKRANY HTML -->
     <div id="startScreen"><h1>MiniSoccer ⚽</h1><button id="startMatchBtn">SZYBKI MECZ</button><div class="start-options"><button id="btnPlayerDB">Baza zawodników</button><button id="btnLanguage">Język</button><button id="btnSettings">Ustawienia</button></div></div>

     <div id="teamSelectScreen" class="hidden">
         <h2>Wybierz Drużyny</h2>
         <div class="team-section" id="homeTeamSection"><h3>Drużyna Domowa</h3><div id="homeTeamContainer" class="team-container"></div></div>
         <div class="team-section" id="awayTeamSection"><h3>Drużyna Gościa</h3><div id="awayTeamContainer" class="team-container"></div></div>
         <div class="button-group"> <!-- Group buttons -->
            <button id="backToMenuFromSelect" class="close-btn">Powrót</button>
            <button id="goToStadiumSelectBtn">Dalej</button> <!-- Changed ID and text -->
         </div>
     </div>

     <!-- === NEW Stadium Selection Screen === -->
     <div id="stadiumSelectScreen" class="hidden">
         <h2>Wybierz Stadion</h2>
         <div id="stadiumContainer" class="stadium-container">
             <!-- Stadium options will be loaded here by JS -->
         </div>
         <div class="button-group"> <!-- Group buttons -->
            <button id="backToTeamSelectBtn" class="close-btn">Powrót</button>
            <button id="startMatchFromStadiumBtn" disabled>Rozpocznij Mecz</button> <!-- Disabled initially -->
         </div>
     </div>
     <!-- === END OF NEW SCREEN === -->

     <div id="gameScreen" class="hidden">
        <div id="scoreboardContainer"><h2 id="scoreboard">— : —</h2><h3 id="matchTimer">Czas: 3:00</h3></div>
        <!-- === ZMIANA: Atrybuty width/height canvas są teraz ustawiane w initGame() === -->
        <canvas id="gameCanvas"></canvas>
        <button id="backToStartBtn">Powrót do Menu</button>
    </div>
     <div id="playerDBModal" class="modal hidden"><div class="modal-content"><h2>Baza zawodników</h2><div id="playerList"></div><h3>Dodaj zawodnika</h3><form id="addPlayerForm"><input type="text" id="playerName" placeholder="Imię i nazwisko" required /><input type="text" id="playerTeam" placeholder="Drużyna" required /><input type="number" id="playerRating" placeholder="Ocena (1-100)" required min="1" max="100" /><button type="submit">Dodaj</button></form><button id="closePlayerDBBtn" class="close-btn">Zamknij</button></div></div>
     <div id="languageModal" class="modal hidden"><div class="modal-content"><h2>Wybór języka</h2><p>Wybierz język interfejsu:</p><button class="langOption" data-lang="pl">Polski</button><button class="langOption" data-lang="en">English</button><button id="closeLanguageModalBtn" class="close-btn">Zamknij</button></div></div>
     <div id="settingsModal" class="modal hidden"><div class="modal-content"><h2>Ustawienia</h2><div class="font-size-options"><h3>Rozmiar czcionki</h3><button class="fontSizeOption" data-size="small">Mała</button><button class="fontSizeOption" data-size="medium">Średnia</button><button class="fontSizeOption" data-size="large">Duża</button></div><hr><button id="closeSettingsModalBtn" class="close-btn">Zamknij</button></div></div>

    <script>
        (function () {
            "use strict";

            // --- GLOBALNE ZMIENNE I STAŁE ---
            let score = { home: 0, away: 0 };
            let canvas, ctx, ball;
            let fieldPlayers = [];
            let fieldPlayersAway = [];
            let goalkeeper, goalkeeperAway;
            let gameAnimating = false;
            let isDragging = false, draggingPlayerIndex = null;
            let dragStartCanvas = { x: 0, y: 0 };
            let dragCurrentCanvas = { x: 0, y: 0 };
            let selectedHomeTeam = null, selectedAwayTeam = null;
            let selectedStadium = null;

            // Stałe fizyki i gry (bez zmian)
            const PLAYER_RADIUS = 15; // Lekko zmniejszony promień dla mniejszego boiska
            const GOALKEEPER_RADIUS = 17; // Lekko zmniejszony
            const BALL_RADIUS = 7;   // Lekko zmniejszony
            const FRICTION = 0.97;
            const PLAYER_FRICTION = 0.95;
            const DRAG_IMPULSE_SCALE = 0.18;
            const MAX_PULL_LENGTH = 160; // Dostosowane do mniejszego boiska
            const COLLISION_RESTITUTION = 0.5;
            const PLAYER_COLLISION_RESTITUTION = 0.3;
            const BALL_COLLISION_BOOST = 1.1;
            const AI_REACTION_POWER = 18; // Dostosowane
            const AI_GOALKEEPER_SPEED = 2.0; // Dostosowane
            const AI_INTERCEPT_RADIUS_SQ = Math.pow(PLAYER_RADIUS + BALL_RADIUS + 60, 2); // Dostosowane
            const AI_SHOT_ACCURACY_FACTOR = 0.18; // Nieco mniejsza celność na mniejszym boisku
            const MATCH_DURATION = 180;
            let matchTime = MATCH_DURATION;
            let matchTimerInterval = null;

            // Elementy UI
             const startScreen = document.getElementById("startScreen");
             const teamSelectScreen = document.getElementById("teamSelectScreen");
             const stadiumSelectScreen = document.getElementById("stadiumSelectScreen");
             const gameScreen = document.getElementById("gameScreen");
             const playerDBModal = document.getElementById("playerDBModal");
             const languageModal = document.getElementById("languageModal");
             const settingsModal = document.getElementById("settingsModal");

             // --- FUNKCJE TIMERA, RESETU ---
             function updateTimerDisplay() { /* ... (bez zmian) ... */ let minutes = Math.floor(matchTime / 60); let seconds = matchTime % 60; if (seconds < 10) seconds = "0" + seconds; const timerElement = document.getElementById("matchTimer"); if(timerElement) timerElement.innerText = "Czas: " + minutes + ":" + seconds; }
             function startTimer() { /* ... (bez zmian) ... */ if (matchTimerInterval) stopTimer(); matchTime = MATCH_DURATION; updateTimerDisplay(); matchTimerInterval = setInterval(() => { matchTime--; updateTimerDisplay(); if (matchTime <= 0) { gameOver(); } }, 1000); }
             function stopTimer() { /* ... (bez zmian) ... */ clearInterval(matchTimerInterval); matchTimerInterval = null; }
             function gameOver() { /* ... (bez zmian) ... */ stopTimer(); gameAnimating = false; const homeName = selectedHomeTeam || "Gospodarze"; const awayName = selectedAwayTeam || "Goście"; alert("Koniec meczu! Wynik: " + homeName + " " + score.home + " : " + score.away + " " + awayName); closeModal(gameScreen); openModal(startScreen); resetGameFull(); }
             function resetGameFull() { /* ... (bez zmian) ... */ if(canvas) { const ctx = canvas.getContext('2d'); ctx.clearRect(0,0, canvas.width, canvas.height); } selectedHomeTeam = null; selectedAwayTeam = null; selectedStadium = null; score = {home: 0, away: 0}; fieldPlayers = []; fieldPlayersAway = []; goalkeeper = null; goalkeeperAway = null; ball = null; /* <<< ZMIANA: Reset tła przy pełnym resecie */ document.body.style.backgroundImage = ''; }
             function updateScoreboard() { /* ... (bez zmian) ... */ const scoreboardElement = document.getElementById("scoreboard"); if(scoreboardElement) { const homeName = selectedHomeTeam || "Dom"; const awayName = selectedAwayTeam || "Gość"; scoreboardElement.innerText = `${homeName} ${score.home} : ${score.away} ${awayName}`; } }

            // --- BAZA DANYCH KLUBÓW ---
            const teamsData = { /* ... (bez zmian - cała długa lista klubów) ... */ "Premier League": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/f2/Premier_League_Logo.svg", teams: [ { name: "Manchester United", logo: "https://upload.wikimedia.org/wikipedia/en/7/7a/Manchester_United_FC_crest.svg" }, { name: "Manchester City", logo: "https://upload.wikimedia.org/wikipedia/en/e/eb/Manchester_City_FC_badge.svg" }, { name: "Liverpool", logo: "https://upload.wikimedia.org/wikipedia/en/0/0c/Liverpool_FC.svg" }, { name: "Chelsea", logo: "https://upload.wikimedia.org/wikipedia/en/c/cc/Chelsea_FC.svg" }, { name: "Arsenal", logo: "https://upload.wikimedia.org/wikipedia/en/5/53/Arsenal_FC.svg" }, { name: "Tottenham Hotspur", logo: "https://upload.wikimedia.org/wikipedia/en/b/b4/Tottenham_Hotspur.svg" } ] }, "La Liga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/9/90/LaLiga.svg", teams: [ { name: "Real Madrid", logo: "https://upload.wikimedia.org/wikipedia/en/5/56/Real_Madrid_CF.svg" }, { name: "Barcelona", logo: "https://upload.wikimedia.org/wikipedia/en/4/47/FC_Barcelona_%28crest%29.svg" }, { name: "Atletico Madrid", logo: "https://brandlogos.net/wp-content/uploads/2021/09/atltico-madrid-logo.png" }, { name: "Sevilla", logo: "https://cdn.freebiesupply.com/logos/large/2x/sevilla-fc-logo-png-transparent.png" }, { name: "Valencia", logo: "https://brandlogos.net/wp-content/uploads/2014/10/valencia_cf-logo_brandlogos.net_iaffl-512x674.png" }, { name: "Villarreal", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Villarreal_CF_logo-en.svg/1200px-Villarreal_CF_logo-en.svg.png" } ] }, "Serie A": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/d/d2/Serie_A_logo_(2019).svg", teams: [ { name: "Juventus", logo: "https://upload.wikimedia.org/wikipedia/commons/d/da/Juventus_Logo.png" }, { name: "Inter Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/0/05/FC_Internazionale_Milano_2021.svg" }, { name: "AC Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Logo_of_AC_Milan.svg/653px-Logo_of_AC_Milan.svg.png" }, { name: "Napoli", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/SSC_Neapel.svg/1200px-SSC_Neapel.svg.png" }, { name: "Roma", logo: "https://upload.wikimedia.org/wikipedia/sco/7/7d/AS_Roma%27s_logo_from_2017.png" }, { name: "Lazio", logo: "https://static.cdnlogo.com/logos/s/89/ss-lazio.png" } ] }, "Bundesliga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/commons/d/df/Bundesliga_logo_(2017).svg", teams: [ { name: "Bayern Munich", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/FC_Bayern_M%C3%BCnchen_logo_(2017).svg/2048px-FC_Bayern_M%C3%BCnchen_logo_(2017).svg.png" }, { name: "Borussia Dortmund", logo: "https://upload.wikimedia.org/wikipedia/commons/7/74/Borussia_Dortmund.png" }, { name: "RB Leipzig", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/0/04/RB_Leipzig_2014_logo.svg/1200px-RB_Leipzig_2014_logo.svg.png" }, { name: "Bayer Leverkusen", logo: "https://cdn.freebiesupply.com/logos/large/2x/bayer-leverkusen-logo-png-transparent.png" }, { name: "Eintracht Frankfurt", logo: "https://logodownload.org/wp-content/uploads/2019/11/eintracht-frankfurt-logo.png" }, { name: "Borussia Mönchengladbach", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Borussia_M%C3%B6nchengladbach_logo.svg/1200px-Borussia_M%C3%B6nchengladbach_logo.svg.png" } ] }, "Ligue 1": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/fd/Ligue_1.svg", teams: [ { name: "Paris Saint-Germain", logo: "https://logos-world.net/wp-content/uploads/2020/07/PSG-Logo.png" }, { name: "Marseille", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Olympique_Marseille_logo.svg/1582px-Olympique_Marseille_logo.svg.png" }, { name: "Lyon", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/1/1c/Olympique_Lyonnais_logo.svg/1200px-Olympique_Lyonnais_logo.svg.png" }, { name: "Monaco", logo: "https://logodownload.org/wp-content/uploads/2019/09/monaco-fc-logo-1.png" }, { name: "Lille", logo: "https://logodownload.org/wp-content/uploads/2019/09/lille-logo-1.png" }, { name: "Nice", logo: "https://1000logos.net/wp-content/uploads/2020/09/Nice-logo.png" } ] } };
            function getTeamColor(teamName) { /* ... (bez zmian - cała długa lista kolorów) ... */ switch(teamName) { case "Manchester United": return "#DA291C"; case "Manchester City": return "#6CABDD"; case "Liverpool": return "#C8102E"; case "Chelsea": return "#034694"; case "Arsenal": return "#EF0107"; case "Tottenham Hotspur": return "#132257"; case "Real Madrid": return "#FEBE10"; case "Barcelona": return "#A50044"; case "Atletico Madrid": return "#CB3524"; case "Sevilla": return "#EC1C24"; case "Valencia": return "#FF8200"; case "Villarreal": return "#FDB913"; case "Juventus": return "#000000"; case "Inter Milan": return "#004D98"; case "AC Milan": return "#DC052D"; case "Napoli": return "#12A0D7"; case "Roma": return "#8E1F2F"; case "Lazio": return "#85B8D0"; case "Bayern Munich": return "#DC052D"; case "Borussia Dortmund": return "#FDE100"; case "RB Leipzig": return "#00AEEF"; case "Bayer Leverkusen": return "#E32221"; case "Eintracht Frankfurt": return "#000000"; case "Borussia Mönchengladbach": return "#000000"; case "Paris Saint-Germain": return "#004170"; case "Marseille": return "#0098D6"; case "Lyon": return "#DA291C"; case "Monaco": return "#E41E2A"; case "Lille": return "#E21C24"; case "Nice": return "#ED1C24"; default: return "#777777"; } }

            // --- NEW: Stadium Data ---
            const stadiumsData = [
                {
                    name: "Anfield",
                    image: "anfield_top_down.jpg" // Użyj tego samego pliku obrazu
                    // Można dodać więcej stadionów w przyszłości
                    // { name: "Old Trafford", image: "old_trafford.jpg" },
                }
                // Można dodać inne stadiony, np.:
                // { name: "Generic Stadium", image: "generic_stadium.jpg" }
            ];

            // --- INICJALIZACJA GRY ---
             function initGame() {
                 canvas = document.getElementById("gameCanvas");
                 if (!canvas) { console.error("Nie znaleziono elementu canvas!"); return; }
                 ctx = canvas.getContext("2d");

                 // <<< ZMIANA: Ustawienie rozmiaru canvas (mniejsze boisko) >>>
                 canvas.width = 640;
                 canvas.height = 400;

                 resizeCanvas(); // Dostosuj styl CSS do nowych wymiarów renderowania

                 ball = { x: canvas.width / 2, y: canvas.height / 2, radius: BALL_RADIUS, vx: 0, vy: 0, color: "white" };
                 let homeColor = getTeamColor(selectedHomeTeam);
                 let awayColor = getTeamColor(selectedAwayTeam);
                 const gkColor = '#CCCCCC';

                 // <<< ZMIANA: 4 zawodników z pola + bramkarz >>>
                 fieldPlayers = [
                     { x: canvas.width * 0.20, y: canvas.height * 0.25, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Obrona L
                     { x: canvas.width * 0.20, y: canvas.height * 0.75, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Obrona P
                     { x: canvas.width * 0.35, y: canvas.height * 0.40, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Pomoc/Atak L
                     { x: canvas.width * 0.35, y: canvas.height * 0.60, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }  // Pomoc/Atak P
                 ];
                 fieldPlayersAway = [
                     { x: canvas.width * 0.80, y: canvas.height * 0.25, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Obrona L (przeciwnika)
                     { x: canvas.width * 0.80, y: canvas.height * 0.75, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Obrona P (przeciwnika)
                     { x: canvas.width * 0.65, y: canvas.height * 0.40, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Pomoc/Atak L (przeciwnika)
                     { x: canvas.width * 0.65, y: canvas.height * 0.60, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }  // Pomoc/Atak P (przeciwnika)
                 ];

                 goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: gkColor }; // Dostosowana pozycja X
                 goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: gkColor }; // Dostosowana pozycja X

                 score.home = 0;
                 score.away = 0;
                 updateScoreboard();
                 console.log(`Match started: ${selectedHomeTeam} vs ${selectedAwayTeam} at ${selectedStadium || 'Default Stadium'}`);
            }

             function resetPositionsAfterGoal(homeJustScored) {
                 if (!canvas || !ball) return;
                 ball.x = canvas.width / 2;
                 ball.y = canvas.height / 2;
                 ball.vx = 0;
                 ball.vy = 0;
                 let homeColor = getTeamColor(selectedHomeTeam);
                 let awayColor = getTeamColor(selectedAwayTeam);
                 const gkColor = '#CCCCCC';

                 // <<< ZMIANA: Reset pozycji dla 4 zawodników z pola >>>
                 fieldPlayers = [
                     { x: canvas.width * 0.20, y: canvas.height * 0.25, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                     { x: canvas.width * 0.20, y: canvas.height * 0.75, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                     { x: canvas.width * 0.35, y: canvas.height * 0.40, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                     { x: canvas.width * 0.35, y: canvas.height * 0.60, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }
                 ];
                 fieldPlayersAway = [
                     { x: canvas.width * 0.80, y: canvas.height * 0.25, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                     { x: canvas.width * 0.80, y: canvas.height * 0.75, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                     { x: canvas.width * 0.65, y: canvas.height * 0.40, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                     { x: canvas.width * 0.65, y: canvas.height * 0.60, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }
                 ];
                 goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: gkColor };
                 goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: gkColor };

                 gameAnimating = false;
                 setTimeout(() => { gameAnimating = true; requestAnimationFrame(gameLoop); }, 1200);
             }


            // --- FUNKCJE RYSOWANIA ---
             function drawField() {
                 if (!ctx) return;
                 const lineWidth = 2; // Cieńsze linie dla mniejszego boiska
                 const goalLineWidth = 4;
                 const midCircleRadius = 50; // Dostosowane
                 const centerDotRadius = 4;
                 const penaltyBoxWidth = 90; // Dostosowane
                 const penaltyBoxHeight = 160; // Dostosowane
                 const goalAreaWidth = 30; // Dostosowane
                 const goalAreaHeight = 60; // Dostosowane
                 const goalWidth = 8; // Dostosowane (szerokość "słupka" na krawędzi)
                 const goalHeight = 40; // Dostosowane (wysokość bramki)

                 ctx.fillStyle = "#2A9D8F"; // Kolor murawy
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                 ctx.lineWidth = lineWidth;

                 // Linie zewnętrzne (z marginesem na słupki)
                 ctx.strokeRect(goalWidth, goalWidth, canvas.width - 2 * goalWidth, canvas.height - 2 * goalWidth);

                 // Linia środkowa
                 ctx.beginPath();
                 ctx.moveTo(canvas.width/2, goalWidth);
                 ctx.lineTo(canvas.width/2, canvas.height - goalWidth);
                 ctx.stroke();

                 // Koło środkowe
                 ctx.beginPath();
                 ctx.arc(canvas.width/2, canvas.height/2, midCircleRadius, 0, Math.PI * 2);
                 ctx.stroke();

                 // Punkt środkowy
                 ctx.beginPath();
                 ctx.arc(canvas.width/2, canvas.height/2, centerDotRadius, 0, Math.PI * 2);
                 ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                 ctx.fill();

                 // Pola karne
                 ctx.strokeRect(goalWidth, canvas.height/2 - penaltyBoxHeight/2, penaltyBoxWidth, penaltyBoxHeight);
                 ctx.strokeRect(canvas.width - goalWidth - penaltyBoxWidth, canvas.height/2 - penaltyBoxHeight/2, penaltyBoxWidth, penaltyBoxHeight);

                 // Pola bramkowe
                 ctx.strokeRect(goalWidth, canvas.height/2 - goalAreaHeight/2, goalAreaWidth, goalAreaHeight);
                 ctx.strokeRect(canvas.width - goalWidth - goalAreaWidth, canvas.height/2 - goalAreaHeight/2, goalAreaWidth, goalAreaHeight);

                 // Bramki (rysujemy słupki)
                 ctx.lineWidth = goalLineWidth;
                 ctx.strokeStyle = "#FFFFFF";
                 // Bramka lewa
                 ctx.beginPath();
                 ctx.moveTo(0, canvas.height/2 - goalHeight);
                 ctx.lineTo(goalWidth, canvas.height/2 - goalHeight); // Górny słupek
                 ctx.moveTo(0, canvas.height/2 + goalHeight);
                 ctx.lineTo(goalWidth, canvas.height/2 + goalHeight); // Dolny słupek
                 ctx.moveTo(goalWidth, canvas.height/2 - goalHeight);
                 ctx.lineTo(goalWidth, canvas.height/2 + goalHeight); // Tylna linia bramki
                 ctx.stroke();
                 // Bramka prawa
                 ctx.beginPath();
                 ctx.moveTo(canvas.width, canvas.height/2 - goalHeight);
                 ctx.lineTo(canvas.width - goalWidth, canvas.height/2 - goalHeight); // Górny słupek
                 ctx.moveTo(canvas.width, canvas.height/2 + goalHeight);
                 ctx.lineTo(canvas.width - goalWidth, canvas.height/2 + goalHeight); // Dolny słupek
                 ctx.moveTo(canvas.width - goalWidth, canvas.height/2 - goalHeight);
                 ctx.lineTo(canvas.width - goalWidth, canvas.height/2 + goalHeight); // Tylna linia bramki
                 ctx.stroke();
             }
             function drawGameObjects() { /* ... (bez zmian) ... */ if (!ctx || !ball) return; const drawPlayer = (player) => { if (!player) return; ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2); ctx.fillStyle = player.color; ctx.fill(); ctx.strokeStyle = "#333"; ctx.lineWidth = 1; ctx.stroke(); ctx.closePath(); }; fieldPlayers.forEach(drawPlayer); fieldPlayersAway.forEach(drawPlayer); drawPlayer(goalkeeper); drawPlayer(goalkeeperAway); ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fillStyle = ball.color; ctx.fill(); ctx.strokeStyle = "black"; ctx.lineWidth = 1; ctx.stroke(); ctx.closePath(); if (isDragging && draggingPlayerIndex !== null) { drawPullLine(); } }
             function drawPullLine() { /* ... (bez zmian) ... */ if (!ctx) return; ctx.save(); let startPoint; if (draggingPlayerIndex >= 0 && fieldPlayers[draggingPlayerIndex]) { startPoint = fieldPlayers[draggingPlayerIndex]; } else if (draggingPlayerIndex === -1 && goalkeeper) { startPoint = goalkeeper; } else { ctx.restore(); return; } ctx.setLineDash([3, 3]); ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(dragCurrentCanvas.x, dragCurrentCanvas.y); ctx.stroke(); let dx = startPoint.x - dragCurrentCanvas.x; let dy = startPoint.y - dragCurrentCanvas.y; let pullLength = Math.hypot(dx, dy); let pullScale = Math.min(1, pullLength / MAX_PULL_LENGTH); if (pullLength > 5) { let arrowEndX = startPoint.x + dx * pullScale * 0.5; let arrowEndY = startPoint.y + dy * pullScale * 0.5; ctx.setLineDash([]); let red = Math.floor(255 * pullScale); let green = Math.floor(255 * (1 - pullScale)); ctx.strokeStyle = `rgba(${red}, ${green}, 0, 0.9)`; ctx.lineWidth = 3 + 2 * pullScale; ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(arrowEndX, arrowEndY); ctx.stroke(); drawArrowhead(ctx, startPoint.x, startPoint.y, arrowEndX, arrowEndY, 8 + 4 * pullScale); } ctx.restore(); }
             function drawArrowhead(context, fromx, fromy, tox, toy, headLength) { /* ... (bez zmian) ... */ var angle = Math.atan2(toy - fromy, tox - fromx); context.beginPath(); context.moveTo(tox, toy); context.lineTo(tox - headLength * Math.cos(angle - Math.PI / 6), toy - headLength * Math.sin(angle - Math.PI / 6)); context.moveTo(tox, toy); context.lineTo(tox - headLength * Math.cos(angle + Math.PI / 6), toy - headLength * Math.sin(angle + Math.PI / 6)); context.stroke(); }

            // --- FUNKCJE FIZYKI I KOLIZJI ---
             function updatePositions() {
                 if (!canvas || !ball) return;
                 const allMovables = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway, ball];
                 const borderMargin = 8; // Zgodnie z goalWidth

                 allMovables.forEach(obj => {
                     if (!obj) return;
                     obj.x += obj.vx;
                     obj.y += obj.vy;
                     let currentFriction = (obj === ball) ? FRICTION : FRICTION * PLAYER_FRICTION;
                     obj.vx *= currentFriction;
                     obj.vy *= currentFriction;
                     if (Math.hypot(obj.vx, obj.vy) < 0.1) { obj.vx = 0; obj.vy = 0; }

                     const restitution = -0.4;
                     // Odbicia od bocznych band (poza linią bramkową)
                     if (obj.x - obj.radius < borderMargin) { obj.x = borderMargin + obj.radius; obj.vx *= restitution; }
                     if (obj.x + obj.radius > canvas.width - borderMargin) { obj.x = canvas.width - borderMargin - obj.radius; obj.vx *= restitution; }
                     // Odbicia od górnej i dolnej bandy
                     if (obj.y - obj.radius < borderMargin) { obj.y = borderMargin + obj.radius; obj.vy *= restitution; }
                     if (obj.y + obj.radius > canvas.height - borderMargin) { obj.y = canvas.height - borderMargin - obj.radius; obj.vy *= restitution; }
                 });

                 confineGoalkeeper(goalkeeper, true);
                 confineGoalkeeper(goalkeeperAway, false);
                 checkGoal(); // Sprawdź gola PO aktualizacji pozycji
             }
             function confineGoalkeeper(gk, isHomeTeam) {
                 if (!gk) return;
                 const borderMargin = 8;
                 const goalHeight = 40; // Zgodne z drawField
                 const penaltyBoxWidth = 90; // Zgodne z drawField

                 const goalTop = canvas.height / 2 - goalHeight;
                 const goalBottom = canvas.height / 2 + goalHeight;
                 // Ograniczenie w pionie - tylko w świetle bramki
                 gk.y = Math.max(goalTop + gk.radius, Math.min(goalBottom - gk.radius, gk.y));

                 // Ograniczenie w poziomie - w polu karnym
                 if (isHomeTeam) {
                    const penaltyAreaFront = borderMargin + penaltyBoxWidth;
                    gk.x = Math.max(borderMargin + gk.radius, Math.min(penaltyAreaFront - gk.radius, gk.x));
                 } else {
                    const penaltyAreaFront = canvas.width - borderMargin - penaltyBoxWidth;
                    gk.x = Math.max(penaltyAreaFront + gk.radius, Math.min(canvas.width - borderMargin - gk.radius, gk.x));
                 }
             }
             function checkGoal() {
                 if (!ball) return;
                 const borderMargin = 8; // Zgodne z goalWidth
                 const goalHeight = 40; // Zgodne z drawField
                 const goalLineYTop = canvas.height/2 - goalHeight;
                 const goalLineYBottom = canvas.height/2 + goalHeight;
                 const goalPostRestitution = -0.5 * COLLISION_RESTITUTION;

                 // Sprawdzenie dla lewej bramki (Away Team zdobywa)
                 if (ball.x - ball.radius < borderMargin) { // Piłka przekroczyła linię bramkową
                     if (ball.y > goalLineYTop && ball.y < goalLineYBottom) { // Czy jest w świetle bramki?
                         console.log("GOL DLA GOŚCI!");
                         score.away++;
                         updateScoreboard();
                         resetPositionsAfterGoal(false); // false = goście zdobyli
                     } else { // Uderzenie w słupek (lub obok)
                         ball.x = borderMargin + ball.radius; // Cofnij piłkę
                         ball.vx *= goalPostRestitution; // Odbij
                     }
                 }
                 // Sprawdzenie dla prawej bramki (Home Team zdobywa)
                 if (ball.x + ball.radius > canvas.width - borderMargin) { // Piłka przekroczyła linię bramkową
                     if (ball.y > goalLineYTop && ball.y < goalLineYBottom) { // Czy jest w świetle bramki?
                         console.log("GOL DLA GOSPODARZY!");
                         score.home++;
                         updateScoreboard();
                         resetPositionsAfterGoal(true); // true = gospodarze zdobyli
                     } else { // Uderzenie w słupek (lub obok)
                         ball.x = canvas.width - borderMargin - ball.radius; // Cofnij piłkę
                         ball.vx *= goalPostRestitution; // Odbij
                     }
                 }
             }
             function circleCollision(c1, c2) { /* ... (bez zmian) ... */ if (!c1 || !c2) return false; const dx = c1.x - c2.x; const dy = c1.y - c2.y; const distance = Math.hypot(dx, dy); const radiiSum = c1.radius + c2.radius; return distance < radiiSum; }
             function resolveCollision(obj1, obj2) { /* ... (bez zmian) ... */ if (!obj1 || !obj2) return; const dx = obj2.x - obj1.x; const dy = obj2.y - obj1.y; const distance = Math.hypot(dx, dy); const radiiSum = obj1.radius + obj2.radius; const overlap = radiiSum - distance; if (overlap > 0 && distance > 0.01) { const nx = dx / distance; const ny = dy / distance; const moveCorrection = overlap / 2; obj1.x -= nx * moveCorrection; obj1.y -= ny * moveCorrection; obj2.x += nx * moveCorrection; obj2.y += ny * moveCorrection; const dvx = obj1.vx - obj2.vx; const dvy = obj1.vy - obj2.vy; const dotProduct = dvx * nx + dvy * ny; if (dotProduct < 0) { let restitution = (obj1 !== ball && obj2 !== ball) ? PLAYER_COLLISION_RESTITUTION : COLLISION_RESTITUTION; const mass1 = (obj1 === ball) ? 0.5 : 1.0; const mass2 = (obj2 === ball) ? 0.5 : 1.0; const invMassSum = (1 / mass1) + (1 / mass2); let impulse = (-(1 + restitution) * dotProduct) / invMassSum; obj1.vx += (impulse / mass1) * nx; obj1.vy += (impulse / mass1) * ny; obj2.vx -= (impulse / mass2) * nx; obj2.vy -= (impulse / mass2) * ny; if (obj1 === ball || obj2 === ball) { ball.vx *= BALL_COLLISION_BOOST; ball.vy *= BALL_COLLISION_BOOST; } } } }
             function checkCollisions() { /* ... (bez zmian) ... */ if (!ball) return; const allPlayers = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway].filter(p => p); const allObjects = [...allPlayers, ball]; for (let i = 0; i < allObjects.length; i++) { for (let j = i + 1; j < allObjects.length; j++) { if (circleCollision(allObjects[i], allObjects[j])) { resolveCollision(allObjects[i], allObjects[j]); } } } }

            // --- SZTUCZNA INTELIGENCJA (AI) ---
            function aiMove() {
                if (!ball || !goalkeeperAway || fieldPlayersAway.length === 0 || !canvas || !gameAnimating) return;

                const goalX = 10; // Cel dla AI (bramka gospodarzy)
                const goalY = canvas.height / 2;
                const borderMargin = 8;

                // Ruch bramkarza AI
                goalkeeperAway.vx *= 0.8; // Stopniowe hamowanie
                goalkeeperAway.vy *= 0.8;
                // Reaguj tylko jeśli piłka jest na połowie AI
                if (ball.x > canvas.width * 0.5) {
                    let dyGK = ball.y - goalkeeperAway.y;
                    // Prosty ruch góra/dół w kierunku piłki
                    if(Math.abs(dyGK) > GOALKEEPER_RADIUS * 0.5) { // Reaguj jeśli piłka jest dalej niż połowa promienia
                         goalkeeperAway.vy += Math.sign(dyGK) * AI_GOALKEEPER_SPEED * 0.1; // Płynniejszy ruch
                    }
                    // Dodaj prosty ruch w kierunku piłki w poziomie, jeśli jest blisko
                    if (ball.x > canvas.width * 0.7) {
                         let dxGK = ball.x - goalkeeperAway.x;
                         goalkeeperAway.vx += Math.sign(dxGK) * AI_GOALKEEPER_SPEED * 0.05;
                    }
                } else {
                    // Powrót do środka bramki, jeśli piłka jest daleko
                    let dyToCenter = (canvas.height / 2) - goalkeeperAway.y;
                    if (Math.abs(dyToCenter) > 5) {
                        goalkeeperAway.vy += Math.sign(dyToCenter) * AI_GOALKEEPER_SPEED * 0.05;
                    }
                     let dxToCenter = (canvas.width - 40) - goalkeeperAway.x; // Celuj w środek pola karnego
                     if (Math.abs(dxToCenter) > 5) {
                         goalkeeperAway.vx += Math.sign(dxToCenter) * AI_GOALKEEPER_SPEED * 0.03;
                     }
                }
                // Ogranicz prędkość bramkarza
                goalkeeperAway.vx = Math.max(-AI_GOALKEEPER_SPEED, Math.min(AI_GOALKEEPER_SPEED, goalkeeperAway.vx));
                goalkeeperAway.vy = Math.max(-AI_GOALKEEPER_SPEED, Math.min(AI_GOALKEEPER_SPEED, goalkeeperAway.vy));


                // Ruch zawodników z pola AI
                let closestPlayerIndex = -1;
                let minDistSq = Infinity;
                let playerWithBall = null;

                // Znajdź najbliższego gracza AI do piłki
                fieldPlayersAway.forEach((player, index) => {
                    if (!player) return;
                    let dx = ball.x - player.x;
                    let dy = ball.y - player.y;
                    let distSq = dx * dx + dy * dy;
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closestPlayerIndex = index;
                    }
                    // Sprawdź, czy ten gracz "ma" piłkę (jest bardzo blisko)
                    if (distSq < Math.pow(player.radius + ball.radius + 2, 2)) {
                         playerWithBall = player;
                    }
                });

                fieldPlayersAway.forEach((player, index) => {
                    if (!player) return;

                    // Zresetuj prędkość (będziemy ją ustawiać)
                    player.vx = 0;
                    player.vy = 0;

                    let dxToBall = ball.x - player.x;
                    let dyToBall = ball.y - player.y;
                    let distToBallSq = dxToBall * dxToBall + dyToBall * dyToBall;
                    let distToBall = Math.sqrt(distToBallSq);

                    if (player === playerWithBall) {
                        // === Logika strzału/dryblingu ===
                        let dxToGoal = goalX - player.x;
                        let dyToGoal = goalY - player.y;
                        let distToGoal = Math.hypot(dxToGoal, dyToGoal);

                        // Decyzja: strzał czy drybling? Prosta wersja: strzelaj jeśli w miarę blisko i na wprost
                        let angleToGoal = Math.atan2(dyToGoal, dxToGoal);
                        let canShoot = player.x > canvas.width * 0.4; // Tylko z połowy przeciwnika

                        if (canShoot && Math.random() < 0.4) { // 40% szans na strzał jeśli można
                            // Strzał w kierunku bramki z lekkim rozrzutem
                            let shootAngle = angleToGoal + (Math.random() - 0.5) * AI_SHOT_ACCURACY_FACTOR * 2;
                            let power = AI_REACTION_POWER * (0.8 + Math.random() * 0.4); // Zmienna siła
                            player.vx = Math.cos(shootAngle) * power;
                            player.vy = Math.sin(shootAngle) * power;
                            console.log("AI Shot!");
                        } else {
                            // Drybling w kierunku bramki
                            let dribbleAngle = angleToGoal;
                            let power = AI_REACTION_POWER * 0.3; // Mniejsza siła dla dryblingu
                             // Lekkie unikanie własnych graczy przy dryblingu (bardzo proste)
                             fieldPlayersAway.forEach(otherPlayer => {
                                 if (player === otherPlayer) return;
                                 let dxOther = otherPlayer.x - player.x;
                                 let dyOther = otherPlayer.y - player.y;
                                 let distOtherSq = dxOther*dxOther + dyOther*dyOther;
                                 if (distOtherSq < Math.pow(PLAYER_RADIUS * 4, 2)) {
                                     dribbleAngle -= Math.sign(dxOther * dyToGoal - dyOther * dxToGoal) * 0.2; // Odbij lekko w bok
                                 }
                             });

                            player.vx = Math.cos(dribbleAngle) * power;
                            player.vy = Math.sin(dribbleAngle) * power;
                        }

                    } else if (index === closestPlayerIndex && distToBallSq < AI_INTERCEPT_RADIUS_SQ) {
                        // === Logika biegu do piłki (najbliższy gracz) ===
                        let interceptPower = AI_REACTION_POWER * 0.4 * (1 - distToBall / Math.sqrt(AI_INTERCEPT_RADIUS_SQ)); // Mocniej im bliżej
                        if (distToBall > 0) {
                            player.vx = (dxToBall / distToBall) * interceptPower;
                            player.vy = (dyToBall / distToBall) * interceptPower;
                        }
                    } else {
                        // === Logika pozycjonowania (pozostali gracze) ===
                        // Bardzo proste: próbują wrócić na swoją "startową" połowę X
                        let targetX = canvas.width * (0.7 + index * 0.05); // Rozłożenie na połowie
                        let targetY = canvas.height * (index % 2 === 0 ? 0.3 : 0.7); // Rozłożenie góra/dół

                        let dxToPos = targetX - player.x;
                        let dyToPos = targetY - player.y;
                        let distToPos = Math.hypot(dxToPos, dyToPos);
                        let positionPower = AI_REACTION_POWER * 0.05;

                        if (distToPos > PLAYER_RADIUS) {
                           player.vx = (dxToPos / distToPos) * positionPower;
                           player.vy = (dyToPos / distToPos) * positionPower;
                        }
                    }
                });
            }


            // --- PĘTLA GŁÓWNA GRY ---
            function gameLoop() {
                 if (!gameAnimating || !ctx) return;
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 drawField();      // Rysuj boisko
                 updatePositions(); // Aktualizuj pozycje (fizyka, granice, bramkarze)
                 checkCollisions(); // Sprawdzaj i rozwiązuj kolizje
                 aiMove();          // Wykonaj ruchy AI
                 drawGameObjects(); // Rysuj graczy i piłkę
                 requestAnimationFrame(gameLoop); // Następna klatka
             }

            // --- OBSŁUGA MYSZY (PRZECIĄGANIE) ---
             function getMousePos(canvas, evt) { /* ... (bez zmian) ... */ if (!canvas) return { x: 0, y: 0 }; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; return { x: (evt.clientX - rect.left) * scaleX, y: (evt.clientY - rect.top) * scaleY }; }
             function canvasMouseDown(e) { /* ... (bez zmian) ... */ if (!canvas || !gameAnimating) return; const pos = getMousePos(canvas, e); for (let i = 0; i < fieldPlayers.length; i++) { const p = fieldPlayers[i]; if (p && Math.hypot(pos.x - p.x, pos.y - p.y) < PLAYER_RADIUS + 5) { draggingPlayerIndex = i; isDragging = true; dragStartCanvas = { x: p.x, y: p.y }; dragCurrentCanvas = pos; canvas.style.cursor = 'grabbing'; return; } } if (goalkeeper && Math.hypot(pos.x - goalkeeper.x, pos.y - goalkeeper.y) < GOALKEEPER_RADIUS + 5) { draggingPlayerIndex = -1; isDragging = true; dragStartCanvas = { x: goalkeeper.x, y: goalkeeper.y }; dragCurrentCanvas = pos; canvas.style.cursor = 'grabbing'; return; } }
             function canvasMouseMove(e) { /* ... (bez zmian) ... */ if (!isDragging || !canvas || !gameAnimating) return; dragCurrentCanvas = getMousePos(canvas, e); }
             function canvasMouseUp(e) {
                if (!isDragging || draggingPlayerIndex === null || !canvas || !gameAnimating) return;
                const dx = dragStartCanvas.x - dragCurrentCanvas.x;
                const dy = dragStartCanvas.y - dragCurrentCanvas.y;
                let pullLength = Math.hypot(dx, dy);

                if (pullLength < 3) { // Jeśli przeciągnięcie jest minimalne, zignoruj (traktuj jak kliknięcie)
                    isDragging = false;
                    draggingPlayerIndex = null;
                    canvas.style.cursor = 'grab';
                    return;
                }

                let pullScale = Math.min(1, pullLength / MAX_PULL_LENGTH);
                const baseImpulse = pullLength * DRAG_IMPULSE_SCALE * pullScale;
                const impulseX = (dx / (pullLength || 1)) * baseImpulse;
                const impulseY = (dy / (pullLength || 1)) * baseImpulse;

                if (draggingPlayerIndex >= 0 && fieldPlayers[draggingPlayerIndex]) {
                    fieldPlayers[draggingPlayerIndex].vx = impulseX;
                    fieldPlayers[draggingPlayerIndex].vy = impulseY;
                } else if (draggingPlayerIndex === -1 && goalkeeper) {
                    // Ogranicz siłę dla bramkarza
                    goalkeeper.vx = impulseX * 0.6;
                    goalkeeper.vy = impulseY * 0.6;
                }
                isDragging = false;
                draggingPlayerIndex = null;
                canvas.style.cursor = 'grab';
             }
             function canvasMouseLeave(e) { /* ... (bez zmian) ... */ if (isDragging) { isDragging = false; draggingPlayerIndex = null; if (canvas) canvas.style.cursor = 'grab'; } }
             function addCanvasEvents() { /* ... (bez zmian) ... */ if (!canvas) return; canvas.addEventListener("mousedown", canvasMouseDown); canvas.addEventListener("mousemove", canvasMouseMove); canvas.addEventListener("mouseup", canvasMouseUp); canvas.addEventListener("mouseleave", canvasMouseLeave); }

            // --- WYBÓR DRUŻYN ---
             function populateTeamSelections() { /* ... (bez zmian) ... */ const homeContainer = document.getElementById("homeTeamContainer"); const awayContainer = document.getElementById("awayTeamContainer"); if (!homeContainer || !awayContainer) return; homeContainer.innerHTML = ""; awayContainer.innerHTML = ""; selectedHomeTeam = null; selectedAwayTeam = null; Object.keys(teamsData).forEach(league => { const leagueData = teamsData[league]; const createLeagueSection = (targetContainer, isHome) => { let leagueDiv = document.createElement("div"); leagueDiv.className = "league-section"; let leagueHeader = document.createElement("div"); leagueHeader.className = "league-header"; let leagueLogo = document.createElement("img"); leagueLogo.src = leagueData.leagueLogo; leagueLogo.alt = league; let leagueName = document.createElement("span"); leagueName.innerText = league; leagueHeader.appendChild(leagueLogo); leagueHeader.appendChild(leagueName); leagueDiv.appendChild(leagueHeader); let teamInnerContainer = document.createElement("div"); teamInnerContainer.style.display = "flex"; teamInnerContainer.style.gap = "15px"; leagueData.teams.forEach(team => { let teamDiv = document.createElement("div"); teamDiv.className = "team-option"; teamDiv.dataset.team = team.name; teamDiv.innerHTML = `<img src="${team.logo}" alt="${team.name}" /><p>${team.name}</p>`; teamDiv.addEventListener("click", function () { Array.from(targetContainer.querySelectorAll('.team-option.selected')).forEach(el => el.classList.remove("selected")); this.classList.add("selected"); if (isHome) selectedHomeTeam = team.name; else selectedAwayTeam = team.name; }); teamInnerContainer.appendChild(teamDiv); }); leagueDiv.appendChild(teamInnerContainer); targetContainer.appendChild(leagueDiv); }; createLeagueSection(homeContainer, true); createLeagueSection(awayContainer, false); }); }

            // --- NEW: Stadium Selection Population ---
            function populateStadiumSelection() {
                const stadiumContainer = document.getElementById("stadiumContainer");
                const startButton = document.getElementById("startMatchFromStadiumBtn");
                if (!stadiumContainer || !startButton) {
                    console.error("Stadium container or start button not found!");
                    return;
                }

                stadiumContainer.innerHTML = ""; // Clear previous options
                selectedStadium = null;      // Reset selection
                startButton.disabled = true; // Disable start button initially

                stadiumsData.forEach(stadium => {
                    let stadiumDiv = document.createElement("div");
                    stadiumDiv.className = "stadium-option";
                    stadiumDiv.dataset.stadium = stadium.name;
                    stadiumDiv.innerHTML = `<img src="${stadium.image}" alt="${stadium.name}" /><p>${stadium.name}</p>`;

                    stadiumDiv.addEventListener("click", function() {
                        // Deselect others
                        Array.from(stadiumContainer.querySelectorAll('.stadium-option.selected')).forEach(el => el.classList.remove("selected"));
                        // Select this one
                        this.classList.add("selected");
                        selectedStadium = stadium.name; // Store the selected stadium name
                        console.log("Selected stadium:", selectedStadium);
                        startButton.disabled = false; // Enable the start button
                    });
                    stadiumContainer.appendChild(stadiumDiv);
                });
            }

            // --- FUNKCJE USTAWIEŃ (Rozmiar czcionki) ---
             const fontSizeOptions = document.querySelectorAll('.fontSizeOption'); function applyFontSize(size) { /* ... (bez zmian) ... */ if (!['small', 'medium', 'large'].includes(size)) { size = 'medium'; } document.body.classList.remove('font-size-small', 'font-size-medium', 'font-size-large'); document.body.classList.add(`font-size-${size}`); localStorage.setItem('gameFontSize', size); fontSizeOptions.forEach(button => { if (button) { button.classList.remove('active-size'); if (button.dataset.size === size) { button.classList.add('active-size'); } } }); console.log("Zastosowano rozmiar czcionki:", size); } function loadFontSize() { /* ... (bez zmian) ... */ const savedSize = localStorage.getItem('gameFontSize') || 'medium'; applyFontSize(savedSize); }

             // --- FUNKCJE POMOCNICZE MODALI ---
              function openModal(modalElement) { if(modalElement) modalElement.classList.remove('hidden'); } function closeModal(modalElement) { if(modalElement) modalElement.classList.add('hidden'); }

            // --- SKALOWANIE CANVAS ---
             function resizeCanvas() {
                 if (!canvas) return;
                 const gameContainer = canvas.parentElement;
                 if (!gameContainer) return;

                 const availableWidth = gameContainer.clientWidth * 0.98; // Dostępna szerokość kontenera
                 const availableHeight = window.innerHeight - 150; // Dostępna wysokość (minus UI)

                 const aspectRatio = canvas.width / canvas.height; // Użyj aktualnych wymiarów canvas z initGame

                 let newWidth = availableWidth;
                 let newHeight = newWidth / aspectRatio;

                 // Jeśli obliczona wysokość jest za duża, skaluj według wysokości
                 if (newHeight > availableHeight) {
                     newHeight = availableHeight;
                     newWidth = newHeight * aspectRatio;
                 }

                 // Ustaw styl CSS canvas (rozmiar wyświetlania), wymiary renderowania (width/height) są z initGame
                 canvas.style.width = `${newWidth}px`;
                 canvas.style.height = `${newHeight}px`;
             }

            // --- GŁÓWNA INICJALIZACJA (DOMContentLoaded) ---
             document.addEventListener("DOMContentLoaded", () => {
                 loadFontSize();
                 window.addEventListener('resize', resizeCanvas); // Przeskaluj przy zmianie rozmiaru okna

                 // Button References
                 const startMatchBtn = document.getElementById("startMatchBtn");
                 const goToStadiumSelectBtn = document.getElementById("goToStadiumSelectBtn");
                 const startMatchFromStadiumBtn = document.getElementById("startMatchFromStadiumBtn");
                 const backToStartBtn = document.getElementById("backToStartBtn");
                 const backToMenuFromSelect = document.getElementById("backToMenuFromSelect");
                 const backToTeamSelectBtn = document.getElementById("backToTeamSelectBtn");
                 const btnPlayerDB = document.getElementById("btnPlayerDB");
                 const btnLanguage = document.getElementById("btnLanguage");
                 const btnSettings = document.getElementById("btnSettings");
                 const closePlayerDBBtn = document.getElementById("closePlayerDBBtn");
                 const closeLanguageModalBtn = document.getElementById("closeLanguageModalBtn");
                 const closeSettingsModalBtn = document.getElementById("closeSettingsModalBtn");
                 const addPlayerForm = document.getElementById("addPlayerForm");
                 const langOptions = document.querySelectorAll(".langOption");

                 // Navigation Listeners
                 if (startMatchBtn) startMatchBtn.addEventListener("click", () => {
                     closeModal(startScreen);
                     openModal(teamSelectScreen);
                     populateTeamSelections();
                 });

                 if (backToMenuFromSelect) backToMenuFromSelect.addEventListener("click", () => {
                     closeModal(teamSelectScreen);
                     openModal(startScreen);
                 });

                 if (goToStadiumSelectBtn) goToStadiumSelectBtn.addEventListener("click", () => {
                     if (!selectedHomeTeam || !selectedAwayTeam) {
                         alert("Proszę wybrać obie drużyny!");
                         return;
                     }
                     if (selectedHomeTeam === selectedAwayTeam) {
                         alert("Drużyny muszą być różne!");
                         return;
                     }
                     closeModal(teamSelectScreen);
                     openModal(stadiumSelectScreen);
                     populateStadiumSelection();
                 });

                 if (backToTeamSelectBtn) backToTeamSelectBtn.addEventListener("click", () => {
                     closeModal(stadiumSelectScreen);
                     openModal(teamSelectScreen);
                 });

                 if (startMatchFromStadiumBtn) startMatchFromStadiumBtn.addEventListener("click", () => {
                     if (!selectedStadium) {
                         alert("Proszę wybrać stadion!");
                         return;
                     }

                     // <<< ZMIANA: Ustawienie tła w zależności od stadionu >>>
                     if (selectedStadium === "Anfield") {
                         document.body.style.backgroundImage = "url('anfield_top_down.jpg')";
                         document.body.style.backgroundSize = "cover";
                         document.body.style.backgroundPosition = "center center";
                         document.body.style.backgroundAttachment = "fixed";
                         // Opcjonalnie, zmień kolor murawy w grze dla Anfield?
                         // np. w initGame można by dodać: if(selectedStadium === "Anfield") ctx.fillStyle = "#347434";
                     } else {
                         // Ustaw inne tło lub usuń specyficzne tło (wróci domyślne z CSS)
                         document.body.style.backgroundImage = '';
                     }

                     closeModal(stadiumSelectScreen);
                     openModal(gameScreen);
                     initGame(); // Inicjalizacja z nowymi wymiarami i liczbą graczy
                     addCanvasEvents();
                     startTimer();
                     gameAnimating = true;
                     requestAnimationFrame(gameLoop);
                 });

                 if (backToStartBtn) backToStartBtn.addEventListener("click", () => {
                     gameAnimating = false;
                     stopTimer();
                     closeModal(gameScreen);
                     openModal(startScreen);
                     // <<< ZMIANA: Usunięcie tła stadionu przy powrocie do menu >>>
                     document.body.style.backgroundImage = '';
                     resetGameFull();
                 });

                 // Modal Buttons
                 if(btnPlayerDB) btnPlayerDB.addEventListener("click", () => openModal(playerDBModal));
                 if(btnLanguage) btnLanguage.addEventListener("click", () => openModal(languageModal));
                 if(btnSettings) btnSettings.addEventListener("click", () => { openModal(settingsModal); const currentSize = localStorage.getItem('gameFontSize') || 'medium'; fontSizeOptions.forEach(button => { if(button) button.classList.toggle('active-size', button.dataset.size === currentSize); }); });
                 if(closePlayerDBBtn) closePlayerDBBtn.addEventListener("click", () => closeModal(playerDBModal));
                 if(closeLanguageModalBtn) closeLanguageModalBtn.addEventListener("click", () => closeModal(languageModal));
                 if(closeSettingsModalBtn) closeSettingsModalBtn.addEventListener("click", () => closeModal(settingsModal));

                 // Font Size Options
                 fontSizeOptions.forEach(button => { if(button) button.addEventListener('click', () => applyFontSize(button.dataset.size)); });

                 // Add Player Form
                 if(addPlayerForm) addPlayerForm.addEventListener("submit", (e) => { /* ... (bez zmian) ... */ e.preventDefault(); const name = document.getElementById("playerName")?.value; const team = document.getElementById("playerTeam")?.value; const rating = document.getElementById("playerRating")?.value; if(name && team && rating){ console.log("Dodawanie gracza:", { name, team, rating }); const playerListDiv = document.getElementById("playerList"); if(playerListDiv){ const newPlayerEntry = document.createElement('p'); newPlayerEntry.textContent = `${name} (${team}) - Ocena: ${rating}`; playerListDiv.appendChild(newPlayerEntry); } e.target.reset(); } else { console.warn("Formularz dodawania gracza: brakuje danych"); } });

                 // Language Options
                 langOptions.forEach(button => { if(button) button.addEventListener("click", () => { /* ... (bez zmian) ... */ const lang = button.dataset.lang; console.log("Zmieniono język na:", lang); /* logika */ closeModal(languageModal); }); });

                 console.log("MiniSoccer v13 - Zmieniono rozmiar boiska, liczbę graczy i dynamiczne tło Anfield");
             });

        })();
    </script>
</body>
</html>
