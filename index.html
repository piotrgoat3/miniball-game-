<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MiniSoccer - Szybki Mecz</title>
    <!-- Łącze do czcionki Nunito -->
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
        rel="stylesheet"
    />
    <style>
        /* --- GLOBALNE STYLE --- */
        :root {
            /* Domyślne rozmiary (odpowiadające średniej) */
            --font-size-h1: 56px;
            --font-size-h2: 40px;
            --font-size-h3: 28px;
            --font-size-button: 20px;
            --font-size-button-padding: 15px 30px;
            --font-size-small-button: 18px;
            --font-size-small-button-padding: 10px 20px;
            --font-size-team-option: 1rem; /* Domyślny rozmiar tekstu */
            --font-size-scoreboard: 28px;
            --font-size-timer: 20px;
        }

        body {
            font-family: "Nunito", sans-serif;
            background: url("https://images.unsplash.com/photo-1578985545062-69928b1d9587?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80")
                no-repeat center center fixed;
            background-size: cover;
            margin: 0;
            padding: 0;
            text-align: center;
            color: #fff;
            font-size: var(--font-size-team-option); /* Używamy zmiennej CSS dla bazowego rozmiaru */
            transition: font-size 0.3s ease; /* Płynne przejście przy zmianie rozmiaru */
        }
        body::before {
            content: "";
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); z-index: -1;
        }
        .hidden { display: none !important; }

        /* --- STYLOWANIE DLA RÓŻNYCH ROZMIARÓW CZCIONEK --- */
        body.font-size-small { --font-size-h1: 48px; --font-size-h2: 34px; --font-size-h3: 24px; --font-size-button: 18px; --font-size-button-padding: 12px 25px; --font-size-small-button: 16px; --font-size-small-button-padding: 8px 16px; --font-size-team-option: 0.9rem; --font-size-scoreboard: 24px; --font-size-timer: 18px; }
        body.font-size-medium { /* Domyślne wartości są już w :root */ }
        body.font-size-large { --font-size-h1: 64px; --font-size-h2: 46px; --font-size-h3: 32px; --font-size-button: 22px; --font-size-button-padding: 18px 35px; --font-size-small-button: 20px; --font-size-small-button-padding: 12px 25px; --font-size-team-option: 1.1rem; --font-size-scoreboard: 32px; --font-size-timer: 22px; }

        /* --- EKRAN STARTOWY --- */
        #startScreen { padding: 40px 20px; }
        #startScreen h1 {
            font-size: var(--font-size-h1); margin-bottom: 30px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        #startScreen button {
            font-size: var(--font-size-button); padding: var(--font-size-button-padding); margin: 15px;
            border: none; border-radius: 10px; background-color: rgba(255,255,255,0.8);
            cursor: pointer; color: #333; box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        #startScreen button:hover {
            background-color: #fff; transform: scale(1.05);
            box-shadow: 0px 5px 15px rgba(0,0,0,0.3);
        }
        .start-options button {
             font-size: var(--font-size-small-button); padding: var(--font-size-small-button-padding);
        }

        /* --- EKRAN WYBORU DRUŻYN --- */
        #teamSelectScreen { padding: 40px 20px; }
        #teamSelectScreen h2 {
            font-size: var(--font-size-h2); margin-bottom: 20px;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
        }
        .team-section { margin: 30px auto; max-width: 800px; text-align: left; }
        .team-section h3 { font-size: var(--font-size-h3); margin-bottom: 15px; padding-left: 10px; }
        .team-container { display: flex; gap: 20px; overflow-x: auto; padding: 10px; scrollbar-width: thin; }
        .team-container::-webkit-scrollbar { height: 8px; }
        .team-container::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 4px; }
        .team-option {
            cursor: pointer; text-align: center; border: 2px solid rgba(255,255,255,0.5);
            border-radius: 12px; width: 150px; padding: 10px; transition: all 0.3s ease;
            flex: 0 0 auto; font-size: var(--font-size-team-option); /* Rozmiar tekstu nazwy drużyny */
        }
        .team-option.selected { border-color: #ffd700; transform: scale(1.1); background-color: rgba(255,255,255,0.2); }
        .team-option img { width: 80px; height: 80px; display: block; margin: 0 auto 10px; }
        .league-header { display: flex; align-items: center; gap: 5px; margin-bottom: 10px; padding-left: 10px; }
        .league-header img { width: 30px; height: 30px; }
        #startMatchFromSelectBtn {
            font-size: var(--font-size-button); padding: var(--font-size-button-padding); margin-top: 30px; cursor: pointer;
            background-color: rgba(255,255,255,0.9); border: none; border-radius: 12px;
            transition: all 0.3s ease; box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        }
        #startMatchFromSelectBtn:hover { background-color: #fff; transform: scale(1.05); box-shadow: 0px 5px 15px rgba(0,0,0,0.3); }

        /* --- EKRAN GRY --- */
        #gameScreen { padding: 20px; }
        #scoreboardContainer { margin-bottom: 20px; }
        #scoreboard { font-size: var(--font-size-scoreboard); font-weight: bold; }
        #matchTimer { font-size: var(--font-size-timer); margin-top: 5px; }
        canvas {
            background-color: #228B22; border: 4px solid #fff; border-radius: 16px;
            display: block; margin: 0 auto; box-shadow: 0px 8px 16px rgba(0,0,0,0.35);
            cursor: grab; /* Kursor łapki nad canvasem */
        }
        canvas:active {
             cursor: grabbing; /* Kursor ściskania podczas przeciągania */
        }
        #backToStartBtn {
            font-size: var(--font-size-small-button); padding: var(--font-size-small-button-padding); margin-top: 20px; cursor: pointer;
            background: rgba(255,255,255,0.9); border: none; border-radius: 10px;
            transition: background 0.3s; box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        }
        #backToStartBtn:hover { background: rgba(255,255,255,1); }

        /* --- MODALE --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; align-items: center;
            justify-content: center; z-index: 100; animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content {
            background: #fff; padding: 30px; width: 90%; max-width: 500px;
            border-radius: 16px; box-shadow: 0 8px 16px rgba(0,0,0,0.35);
            color: #333;
        }
        .modal-content h2 { margin-top: 0; font-size: var(--font-size-h3); } /* Użycie zmiennej */
        .modal-content h3 { font-size: calc(var(--font-size-h3) * 0.8); } /* Dostosowanie */
        .modal-content p { font-size: var(--font-size-team-option); } /* Użycie zmiennej */
        .modal-content button {
            font-size: var(--font-size-small-button); /* Użycie zmiennej */
            padding: var(--font-size-small-button-padding); /* Użycie zmiennej */
            background: rgba(50, 150, 50, 0.8); /* Lekko zielony */
            border: none; border-radius: 6px; margin-top: 10px; margin-right: 5px; /* Dodano margines */
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0px 2px 4px rgba(0,0,0,0.25); cursor: pointer; color: white; /* Biały tekst */
        }
        .modal-content button:hover {
            background: rgba(30, 120, 30, 1); /* Ciemniejszy zielony */
            transform: translateY(-2px);
        }
        /* Specyficzny styl dla przycisku zamknięcia */
        .modal-content button.close-btn {
             background: rgba(200, 50, 50, 0.8); /* Czerwony */
        }
         .modal-content button.close-btn:hover {
             background: rgba(170, 30, 30, 1); /* Ciemniejszy czerwony */
        }
        /* Aktywny przycisk rozmiaru czcionki */
        .modal-content button.active-size {
             background: rgba(30, 120, 30, 1); /* Ciemniejszy zielony dla aktywnego */
             box-shadow: inset 0px 2px 4px rgba(0,0,0,0.3);
        }
        input {
            border: 1px solid #ccc; border-radius: 6px; padding: 10px;
            margin: 5px 0; width: calc(100% - 22px); /* Dostosowanie szerokości */
            box-sizing: border-box; font-size: var(--font-size-team-option); /* Użycie zmiennej */
        }
        #playerList {
            max-height: 300px; overflow-y: auto; scrollbar-width: thin;
            scrollbar-color: #185c28 #ffffff; margin-bottom: 15px; /* Dodano margines */
            font-size: var(--font-size-team-option); /* Użycie zmiennej */
        }
        #playerList::-webkit-scrollbar { width: 8px; }
        #playerList::-webkit-scrollbar-thumb { background: #185c28; border-radius: 5px; }
        #playerList::-webkit-scrollbar-track { background: #ffffff; }
        #addPlayerForm button { /* Zastosuj zielony styl do przycisku Dodaj */
             margin-top: 10px; margin-right: 0; /* Reset marginesu dla tego przycisku */
        }
        .font-size-options { margin-top: 15px; margin-bottom: 20px; } /* Odstępy dla opcji czcionki */
    </style>
</head>
<body class="font-size-medium"> <!-- Domyślnie średnia czcionka -->
    <!-- EKRAN STARTOWY -->
    <div id="startScreen">
        <h1>MiniSoccer ⚽</h1>
        <button id="startMatchBtn">SZYBKI MECZ</button>
        <div class="start-options">
            <button id="btnPlayerDB">Baza zawodników</button>
            <button id="btnLanguage">Język</button>
            <button id="btnSettings">Ustawienia</button> <!-- Przycisk Ustawienia -->
        </div>
    </div>

    <!-- EKRAN WYBORU DRUŻYN -->
    <div id="teamSelectScreen" class="hidden">
        <h2>Wybierz Drużyny</h2>
        <div class="team-section" id="homeTeamSection">
            <h3>Drużyna Domowa</h3>
            <div id="homeTeamContainer" class="team-container"></div>
        </div>
        <div class="team-section" id="awayTeamSection">
            <h3>Drużyna Gościa</h3>
            <div id="awayTeamContainer" class="team-container"></div>
        </div>
        <button id="startMatchFromSelectBtn">Rozpocznij Mecz</button>
    </div>

    <!-- EKRAN GRY -->
    <div id="gameScreen" class="hidden">
        <div id="scoreboardContainer">
            <h2 id="scoreboard">— : —</h2>
            <h3 id="matchTimer">Czas: 3:00</h3>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <button id="backToStartBtn">Powrót do Menu</button>
    </div>

    <!-- MODALE -->
    <div id="playerDBModal" class="modal hidden">
        <div class="modal-content">
            <h2>Baza zawodników</h2>
            <div id="playerList"></div>
            <h3>Dodaj zawodnika</h3>
            <form id="addPlayerForm">
                <input type="text" id="playerName" placeholder="Imię i nazwisko" required />
                <input type="text" id="playerTeam" placeholder="Drużyna" required />
                <input type="number" id="playerRating" placeholder="Ocena" required min="0" max="100" />
                <button type="submit">Dodaj</button>
            </form>
            <button id="closePlayerDBBtn" class="close-btn">Zamknij</button> <!-- Dodano klasę close-btn -->
        </div>
    </div>

    <div id="languageModal" class="modal hidden">
        <div class="modal-content">
            <h2>Wybór języka</h2>
            <p>Wybierz język interfejsu:</p>
            <button class="langOption" data-lang="pl">Polski</button>
            <button class="langOption" data-lang="en">English</button>
            <button id="closeLanguageModalBtn" class="close-btn">Zamknij</button> <!-- Dodano klasę close-btn -->
        </div>
    </div>

    <!-- NOWY MODAL: USTAWIEŃ -->
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <h2>Ustawienia</h2>
            <div class="font-size-options">
                 <h3>Rozmiar czcionki</h3>
                 <button class="fontSizeOption" data-size="small">Mała</button>
                 <button class="fontSizeOption" data-size="medium">Średnia</button>
                 <button class="fontSizeOption" data-size="large">Duża</button>
            </div>
            <hr> <!-- Linia oddzielająca -->
             <!-- Tutaj można dodać więcej ustawień w przyszłości -->
            <button id="closeSettingsModalBtn" class="close-btn">Zamknij</button> <!-- Dodano klasę close-btn -->
        </div>
    </div>

    <script>
        (function () {
            "use strict";

            // --- GLOBALNE ZMIENNE I STAŁE ---
            let score = { home: 0, away: 0 };
            let canvas, ctx, ball;
            let fieldPlayers = []; // Gracze domowi (bez bramkarza)
            let fieldPlayersAway = []; // Gracze gości (bez bramkarza)
            let goalkeeper, goalkeeperAway; // Bramkarze
            let gameAnimating = false;
            let isDragging = false, draggingPlayerIndex = null; // null: nic, -1: bramkarz domowy, >=0: zawodnik domowy
            let dragStart = { x: 0, y: 0 }, dragCurrent = { x: 0, y: 0 };
            let selectedHomeTeam = null, selectedAwayTeam = null;

            const PLAYER_RADIUS = 16;
            const GOALKEEPER_RADIUS = 18;
            const BALL_RADIUS = 8;
            const FRICTION = 0.98; // Tarcie ogólne
            const PLAYER_FRICTION = 0.96; // Dodatkowe tarcie dla graczy
            const BALL_FRICTION = 0.99; // Mniejsze tarcie dla piłki
            const DRAG_IMPULSE_SCALE = 0.06; // Siła naciągu
            const MAX_PULL_LENGTH = 150; // Maksymalna długość naciągu wpływająca na siłę
            const COLLISION_RESTITUTION = 0.6; // Sprężystość odbić (0-1)
            const PLAYER_COLLISION_RESTITUTION = 0.4; // Mniejsza sprężystość zderzeń między graczami
            const BALL_COLLISION_BOOST = 1.05; // Lekkie przyspieszenie piłki po odbiciu od gracza

            // AI
            const AI_ACTIVE_SPEED = 0.08; // Siła impulsu dla aktywnego gracza AI
            const AI_PASSIVE_SPEED = 0.03; // Siła impulsu dla pasywnego gracza AI
            const AI_GOALKEEPER_SPEED = 1.4; // Prędkość ruchu bramkarza AI
            const AI_REACTION_DELAY = 100; // Opcjonalne opóźnienie reakcji AI (w ms) - obecnie nieużywane, ruch jest natychmiastowy
            const MAX_AI_PLAYER_SPEED = 3.5; // Maksymalna prędkość aktywnego gracza AI
            const MAX_AI_PASSIVE_SPEED = 1.5; // Maksymalna prędkość pasywnego gracza AI


            // CZAS MECZU
            const MATCH_DURATION = 180; // 3 minuty
            let matchTime = MATCH_DURATION;
            let matchTimerInterval = null;

            // Elementy UI
            const startScreen = document.getElementById("startScreen");
            const teamSelectScreen = document.getElementById("teamSelectScreen");
            const gameScreen = document.getElementById("gameScreen");
            const playerDBModal = document.getElementById("playerDBModal");
            const languageModal = document.getElementById("languageModal");
            const settingsModal = document.getElementById("settingsModal");

            // --- FUNKCJE TIMERA ---
            function updateTimerDisplay() {
                let minutes = Math.floor(matchTime / 60);
                let seconds = matchTime % 60;
                if (seconds < 10) seconds = "0" + seconds;
                const timerElement = document.getElementById("matchTimer");
                if(timerElement) timerElement.innerText = "Czas: " + minutes + ":" + seconds;
            }
            function startTimer() {
                if (matchTimerInterval) stopTimer();
                matchTime = MATCH_DURATION;
                updateTimerDisplay();
                matchTimerInterval = setInterval(() => {
                    matchTime--;
                    updateTimerDisplay();
                    if (matchTime <= 0) {
                        gameOver();
                    }
                }, 1000);
            }
            function stopTimer() {
                clearInterval(matchTimerInterval);
                matchTimerInterval = null;
            }
            function gameOver() {
                stopTimer();
                gameAnimating = false;
                const homeName = selectedHomeTeam || "Gospodarze";
                const awayName = selectedAwayTeam || "Goście";
                alert("Koniec meczu! Wynik: " + homeName + " " + score.home + " : " + score.away + " " + awayName);
                closeModal(gameScreen);
                openModal(startScreen);
                resetGameFull(); // Pełny reset stanu gry
            }
            function resetGameFull() {
                 if(canvas) {
                     const ctx = canvas.getContext('2d');
                     ctx.clearRect(0,0, canvas.width, canvas.height);
                 }
                 selectedHomeTeam = null;
                 selectedAwayTeam = null;
                 score = {home: 0, away: 0};
                 fieldPlayers = [];
                 fieldPlayersAway = [];
                 goalkeeper = null;
                 goalkeeperAway = null;
                 ball = null;
            }

            // --- BAZA DANYCH KLUBÓW ---
            const teamsData = { /* ... (bez zmian, jak w poprzedniej wersji) ... */
                 "Premier League": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/f2/Premier_League_Logo.svg", teams: [ { name: "Manchester United", logo: "https://upload.wikimedia.org/wikipedia/en/7/7a/Manchester_United_FC_crest.svg" }, { name: "Manchester City", logo: "https://upload.wikimedia.org/wikipedia/en/e/eb/Manchester_City_FC_badge.svg" }, { name: "Liverpool", logo: "https://upload.wikimedia.org/wikipedia/en/0/0c/Liverpool_FC.svg" }, { name: "Chelsea", logo: "https://upload.wikimedia.org/wikipedia/en/c/cc/Chelsea_FC.svg" }, { name: "Arsenal", logo: "https://upload.wikimedia.org/wikipedia/en/5/53/Arsenal_FC.svg" }, { name: "Tottenham Hotspur", logo: "https://upload.wikimedia.org/wikipedia/en/b/b4/Tottenham_Hotspur.svg" } ] },
                 "La Liga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/9/90/LaLiga.svg", teams: [ { name: "Real Madrid", logo: "https://upload.wikimedia.org/wikipedia/en/5/56/Real_Madrid_CF.svg" }, { name: "Barcelona", logo: "https://upload.wikimedia.org/wikipedia/en/4/47/FC_Barcelona_%28crest%29.svg" }, { name: "Atletico Madrid", logo: "https://brandlogos.net/wp-content/uploads/2021/09/atltico-madrid-logo.png" }, { name: "Sevilla", logo: "https://cdn.freebiesupply.com/logos/large/2x/sevilla-fc-logo-png-transparent.png" }, { name: "Valencia", logo: "https://brandlogos.net/wp-content/uploads/2014/10/valencia_cf-logo_brandlogos.net_iaffl-512x674.png" }, { name: "Villarreal", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Villarreal_CF_logo-en.svg/1200px-Villarreal_CF_logo-en.svg.png" } ] },
                 "Serie A": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/d/d2/Serie_A_logo_(2019).svg", teams: [ { name: "Juventus", logo: "https://upload.wikimedia.org/wikipedia/commons/d/da/Juventus_Logo.png" }, { name: "Inter Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/0/05/FC_Internazionale_Milano_2021.svg" }, { name: "AC Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Logo_of_AC_Milan.svg/653px-Logo_of_AC_Milan.svg.png" }, { name: "Napoli", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/SSC_Neapel.svg/1200px-SSC_Neapel.svg.png" }, { name: "Roma", logo: "https://upload.wikimedia.org/wikipedia/sco/7/7d/AS_Roma%27s_logo_from_2017.png" }, { name: "Lazio", logo: "https://static.cdnlogo.com/logos/s/89/ss-lazio.png" } ] },
                 "Bundesliga": { leagueLogo: "https://upload.wikimedia.org/wikipedia/commons/d/df/Bundesliga_logo_(2017).svg", teams: [ { name: "Bayern Munich", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/FC_Bayern_M%C3%BCnchen_logo_(2017).svg/2048px-FC_Bayern_M%C3%BCnchen_logo_(2017).svg.png" }, { name: "Borussia Dortmund", logo: "https://upload.wikimedia.org/wikipedia/commons/7/74/Borussia_Dortmund.png" }, { name: "RB Leipzig", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/0/04/RB_Leipzig_2014_logo.svg/1200px-RB_Leipzig_2014_logo.svg.png" }, { name: "Bayer Leverkusen", logo: "https://cdn.freebiesupply.com/logos/large/2x/bayer-leverkusen-logo-png-transparent.png" }, { name: "Eintracht Frankfurt", logo: "https://logodownload.org/wp-content/uploads/2019/11/eintracht-frankfurt-logo.png" }, { name: "Borussia Mönchengladbach", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Borussia_M%C3%B6nchengladbach_logo.svg/1200px-Borussia_M%C3%B6nchengladbach_logo.svg.png" } ] },
                 "Ligue 1": { leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/fd/Ligue_1.svg", teams: [ { name: "Paris Saint-Germain", logo: "https://logos-world.net/wp-content/uploads/2020/07/PSG-Logo.png" }, { name: "Marseille", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Olympique_Marseille_logo.svg/1582px-Olympique_Marseille_logo.svg.png" }, { name: "Lyon", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/1/1c/Olympique_Lyonnais_logo.svg/1200px-Olympique_Lyonnais_logo.svg.png" }, { name: "Monaco", logo: "https://logodownload.org/wp-content/uploads/2019/09/monaco-fc-logo-1.png" }, { name: "Lille", logo: "https://logodownload.org/wp-content/uploads/2019/09/lille-logo-1.png" }, { name: "Nice", logo: "https://1000logos.net/wp-content/uploads/2020/09/Nice-logo.png" } ] }
            };

            /* Funkcja pomocnicza – zwraca kolor klubowy */
            function getTeamColor(teamName) { /* ... (bez zmian) ... */
                switch(teamName) {
                     case "Manchester United": return "#DA291C"; case "Manchester City": return "#6CABDD"; case "Liverpool": return "#C8102E"; case "Chelsea": return "#034694"; case "Arsenal": return "#EF0107"; case "Tottenham Hotspur": return "#132257";
                     case "Real Madrid": return "#FEBE10"; case "Barcelona": return "#A50044"; case "Atletico Madrid": return "#CB3524"; case "Sevilla": return "#EC1C24"; case "Valencia": return "#FF8200"; case "Villarreal": return "#FDB913";
                     case "Juventus": return "#000000"; case "Inter Milan": return "#004D98"; case "AC Milan": return "#DC052D"; case "Napoli": return "#12A0D7"; case "Roma": return "#8E1F2F"; case "Lazio": return "#85B8D0";
                     case "Bayern Munich": return "#DC052D"; case "Borussia Dortmund": return "#FDE100"; case "RB Leipzig": return "#00AEEF"; case "Bayer Leverkusen": return "#E32221"; case "Eintracht Frankfurt": return "#000000"; case "Borussia Mönchengladbach": return "#000000";
                     case "Paris Saint-Germain": return "#004170"; case "Marseille": return "#0098D6"; case "Lyon": return "#DA291C"; case "Monaco": return "#E41E2A"; case "Lille": return "#E21C24"; case "Nice": return "#ED1C24";
                     default: return "#777777"; // Domyślny szary
                }
            }

            // --- FUNKCJE INICJALIZACJI I RESETU GRY ---
            function initGame() {
                canvas = document.getElementById("gameCanvas");
                if (!canvas) { console.error("Nie znaleziono elementu canvas!"); return; }
                ctx = canvas.getContext("2d");
                ball = { x: canvas.width / 2, y: canvas.height / 2, radius: BALL_RADIUS, vx: 0, vy: 0, color: "white" };

                let homeColor = getTeamColor(selectedHomeTeam);
                let awayColor = getTeamColor(selectedAwayTeam);

                // Ustawienie początkowe - 3 zawodników w polu + bramkarz (2-1)
                fieldPlayers = [
                    { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Left Wing
                    { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }, // Right Wing
                    { x: canvas.width * 0.35, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }  // Center Forward
                ];
                fieldPlayersAway = [
                    { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Right Wing (Def)
                    { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }, // Left Wing (Def)
                    { x: canvas.width * 0.65, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }  // Center Back
                ];

                goalkeeper = { x: 50, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor }; // Slightly closer to goal
                goalkeeperAway = { x: canvas.width - 50, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor }; // Slightly closer to goal

                score.home = 0; score.away = 0;
                updateScoreboard();
            }
            function resetPositionsAfterGoal(homeJustScored) {
                 // Reset piłki
                 ball.x = canvas.width / 2;
                 ball.y = canvas.height / 2;
                 ball.vx = 0;
                 ball.vy = 0;

                 // Reset zawodników do pozycji startowych (jak w initGame)
                 let homeColor = getTeamColor(selectedHomeTeam);
                 let awayColor = getTeamColor(selectedAwayTeam);
                 fieldPlayers = [
                     { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                     { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                     { x: canvas.width * 0.35, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }
                 ];
                 fieldPlayersAway = [
                     { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                     { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                     { x: canvas.width * 0.65, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }
                 ];
                 goalkeeper = { x: 50, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor };
                 goalkeeperAway = { x: canvas.width - 50, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor };

                 // Pauza przed wznowieniem
                 gameAnimating = false;
                 setTimeout(() => {
                     gameAnimating = true;
                     requestAnimationFrame(gameLoop);
                 }, 1200); // 1.2 sekundy pauzy
            }
            function updateScoreboard() {
                const scoreboardElement = document.getElementById("scoreboard");
                if(scoreboardElement) {
                    const homeName = selectedHomeTeam || "Dom"; // Domyślne nazwy
                    const awayName = selectedAwayTeam || "Gość";
                    scoreboardElement.innerText = `${homeName} ${score.home} : ${score.away} ${awayName}`;
                }
            }

            // --- FUNKCJE RYSOWANIA ---
            function drawField() { /* ... (bez zmian, jak w poprzedniej wersji) ... */
                if (!ctx) return;
                 // Tło (trawa)
                 ctx.fillStyle = "#228B22"; // Kolor trawy
                 ctx.fillRect(0, 0, canvas.width, canvas.height);

                 // Linie boiska
                 ctx.strokeStyle = "rgba(255, 255, 255, 0.7)"; // Półprzezroczyste białe linie
                 ctx.lineWidth = 3;

                 // Zewnętrzna ramka
                 ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
                 // Linia środkowa
                 ctx.beginPath();
                 ctx.moveTo(canvas.width/2, 10);
                 ctx.lineTo(canvas.width/2, canvas.height - 10);
                 ctx.stroke();
                 // Koło środkowe
                 ctx.beginPath();
                 ctx.arc(canvas.width/2, canvas.height/2, 60, 0, Math.PI * 2);
                 ctx.stroke();
                  // Kropka na środku
                 ctx.beginPath();
                 ctx.arc(canvas.width/2, canvas.height/2, 5, 0, Math.PI * 2);
                 ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                 ctx.fill();


                 // Pola karne
                 ctx.strokeRect(10, canvas.height/2 - 100, 120, 200); // Większe pole karne
                 ctx.strokeRect(canvas.width - 10 - 120, canvas.height/2 - 100, 120, 200);

                 // Pola bramkowe (małe)
                 ctx.strokeRect(10, canvas.height/2 - 40, 40, 80);
                 ctx.strokeRect(canvas.width - 10 - 40, canvas.height/2 - 40, 40, 80);

                 // Bramki (grubsze linie)
                 ctx.lineWidth = 6;
                 ctx.strokeStyle = "#FFFFFF"; // Pełny biały dla bramek
                 ctx.beginPath(); ctx.moveTo(0, canvas.height/2 - 50); ctx.lineTo(10, canvas.height/2 - 50); ctx.stroke(); // Lewa górna
                 ctx.beginPath(); ctx.moveTo(0, canvas.height/2 + 50); ctx.lineTo(10, canvas.height/2 + 50); ctx.stroke(); // Lewa dolna
                 ctx.beginPath(); ctx.moveTo(10, canvas.height/2 - 50); ctx.lineTo(10, canvas.height/2 + 50); ctx.stroke(); // Lewy słupek


                 ctx.beginPath(); ctx.moveTo(canvas.width, canvas.height/2 - 50); ctx.lineTo(canvas.width - 10, canvas.height/2 - 50); ctx.stroke(); // Prawa górna
                 ctx.beginPath(); ctx.moveTo(canvas.width, canvas.height/2 + 50); ctx.lineTo(canvas.width - 10, canvas.height/2 + 50); ctx.stroke(); // Prawa dolna
                 ctx.beginPath(); ctx.moveTo(canvas.width - 10, canvas.height/2 - 50); ctx.lineTo(canvas.width - 10, canvas.height/2 + 50); ctx.stroke(); // Prawy słupek
            }
            function drawGameObjects() {
                 if (!ctx || !ball) return;

                 const drawPlayer = (player) => {
                    if (!player) return;
                     ctx.beginPath();
                     ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
                     ctx.fillStyle = player.color;
                     ctx.fill();
                     ctx.strokeStyle = "#333"; ctx.lineWidth = 1; ctx.stroke(); // Obramowanie
                     ctx.closePath();
                 };

                 fieldPlayers.forEach(drawPlayer);
                 fieldPlayersAway.forEach(drawPlayer);
                 drawPlayer(goalkeeper);
                 drawPlayer(goalkeeperAway);

                 // Piłka
                 ctx.beginPath();
                 ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
                 ctx.fillStyle = ball.color; ctx.fill();
                 ctx.strokeStyle = "black"; ctx.lineWidth = 1; ctx.stroke(); // Obramowanie
                 ctx.closePath();

                 // Linia naciągu
                 if (isDragging && draggingPlayerIndex !== null && dragStart && dragCurrent) {
                      drawPullLine();
                 }
            }
            function drawPullLine() {
                if (!ctx) return;
                 ctx.save();
                 let startPoint;
                 if (draggingPlayerIndex >= 0 && fieldPlayers[draggingPlayerIndex]) {
                     startPoint = fieldPlayers[draggingPlayerIndex];
                 } else if (draggingPlayerIndex === -1 && goalkeeper) {
                     startPoint = goalkeeper;
                 } else {
                     ctx.restore(); return; // Nie ma czego rysować
                 }

                 // Linia od gracza do kursora (cienka, przerywana)
                 ctx.setLineDash([3, 3]);
                 ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 ctx.moveTo(startPoint.x, startPoint.y);
                 ctx.lineTo(dragCurrent.x, dragCurrent.y);
                 ctx.stroke();

                 // Wektor siły (przeciwny do naciągu)
                 let dx = startPoint.x - dragCurrent.x;
                 let dy = startPoint.y - dragCurrent.y;
                 let pullLength = Math.hypot(dx, dy);
                 let pullScale = Math.min(1, pullLength / MAX_PULL_LENGTH); // Skalowanie 0-1

                 if (pullLength > 5) { // Rysuj tylko, gdy jest naciąg
                     let arrowEndX = startPoint.x + dx * pullScale * 0.5; // Skaluj długość strzałki
                     let arrowEndY = startPoint.y + dy * pullScale * 0.5;

                     // Strzałka (grubsza, ciągła, kolor zależny od siły)
                     ctx.setLineDash([]);
                     // Kolor od żółtego (mała siła) do czerwonego (duża siła)
                     let red = Math.floor(255 * pullScale);
                     let green = Math.floor(255 * (1 - pullScale));
                     ctx.strokeStyle = `rgba(${red}, ${green}, 0, 0.9)`;
                     ctx.lineWidth = 3 + 2 * pullScale; // Grubość zależna od siły
                     ctx.beginPath();
                     ctx.moveTo(startPoint.x, startPoint.y);
                     ctx.lineTo(arrowEndX, arrowEndY);
                     ctx.stroke();
                     // Grot strzałki
                     drawArrowhead(ctx, startPoint.x, startPoint.y, arrowEndX, arrowEndY, 8 + 4 * pullScale);
                 }
                 ctx.restore();
            }
            function drawArrowhead(context, fromx, fromy, tox, toy, headLength) { /* ... (bez zmian) ... */
                var angle = Math.atan2(toy - fromy, tox - fromx);
                context.beginPath();
                context.moveTo(tox, toy);
                context.lineTo(tox - headLength * Math.cos(angle - Math.PI / 6), toy - headLength * Math.sin(angle - Math.PI / 6));
                context.moveTo(tox, toy);
                context.lineTo(tox - headLength * Math.cos(angle + Math.PI / 6), toy - headLength * Math.sin(angle + Math.PI / 6));
                context.stroke();
            }

            // --- FUNKCJE FIZYKI I KOLIZJI ---
            function updatePositions() {
                if (!canvas || !ball) return;
                const allMovables = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway, ball];

                allMovables.forEach(obj => {
                    if (!obj) return;
                    obj.x += obj.vx;
                    obj.y += obj.vy;

                    // Tarcie
                    let currentFriction = (obj === ball) ? BALL_FRICTION : PLAYER_FRICTION;
                    obj.vx *= currentFriction * FRICTION; // Łączymy oba tarcia
                    obj.vy *= currentFriction * FRICTION;

                    // Zatrzymanie przy bardzo małej prędkości
                    if (Math.hypot(obj.vx, obj.vy) < 0.05) {
                        obj.vx = 0; obj.vy = 0;
                    }

                    // Kolizje z bandami (oprócz linii bramkowych dla piłki)
                    if (obj !== ball) { // Gracze odbijają się od wszystkich band
                        if (obj.x - obj.radius < 10) { obj.x = 10 + obj.radius; obj.vx *= -0.5; }
                        if (obj.x + obj.radius > canvas.width - 10) { obj.x = canvas.width - 10 - obj.radius; obj.vx *= -0.5; }
                        if (obj.y - obj.radius < 10) { obj.y = 10 + obj.radius; obj.vy *= -0.5; }
                        if (obj.y + obj.radius > canvas.height - 10) { obj.y = canvas.height - 10 - obj.radius; obj.vy *= -0.5; }
                    } else { // Piłka odbija się tylko od górnej i dolnej bandy
                         if (obj.y - obj.radius < 10) { obj.y = 10 + obj.radius; obj.vy *= -COLLISION_RESTITUTION; }
                         if (obj.y + obj.radius > canvas.height - 10) { obj.y = canvas.height - 10 - obj.radius; obj.vy *= -COLLISION_RESTITUTION; }
                    }
                });

                 // Ograniczenie ruchu bramkarzy
                 confineGoalkeeper(goalkeeper, true);
                 confineGoalkeeper(goalkeeperAway, false);

                // Sprawdzenie gola
                checkGoal();
            }
            function confineGoalkeeper(gk, isHomeTeam) {
                if (!gk) return;
                 const goalTop = canvas.height / 2 - 50; // Linia bramki góra
                 const goalBottom = canvas.height / 2 + 50; // Linia bramki dół
                 const penaltyAreaFront = isHomeTeam ? 10 + 120 : canvas.width - 10 - 120; // Linia pola karnego

                 // Ograniczenie pionowe (wewnątrz słupków + promień)
                 gk.y = Math.max(goalTop + gk.radius, Math.min(goalBottom - gk.radius, gk.y));

                 // Ograniczenie poziome (wewnątrz pola karnego)
                 if (isHomeTeam) {
                     gk.x = Math.max(10 + gk.radius, Math.min(penaltyAreaFront - gk.radius, gk.x));
                 } else {
                     gk.x = Math.max(penaltyAreaFront + gk.radius, Math.min(canvas.width - 10 - gk.radius, gk.x));
                 }
            }
            function checkGoal() {
                 if (!ball) return;
                 const goalLineYTop = canvas.height/2 - 50;
                 const goalLineYBottom = canvas.height/2 + 50;

                 // Gol dla gości (piłka przekracza lewą linię)
                 if (ball.x - ball.radius < 10) {
                     if (ball.y > goalLineYTop && ball.y < goalLineYBottom) {
                         score.away++;
                         updateScoreboard();
                         resetPositionsAfterGoal(false); // homeJustScored = false
                     } else { // Odbicie od słupka
                         ball.x = 10 + ball.radius;
                         ball.vx *= -COLLISION_RESTITUTION * 0.8; // Mniejsze odbicie od słupka
                     }
                 }
                 // Gol dla gospodarzy (piłka przekracza prawą linię)
                 if (ball.x + ball.radius > canvas.width - 10) {
                      if (ball.y > goalLineYTop && ball.y < goalLineYBottom) {
                         score.home++;
                         updateScoreboard();
                         resetPositionsAfterGoal(true); // homeJustScored = true
                      } else { // Odbicie od słupka
                         ball.x = canvas.width - 10 - ball.radius;
                         ball.vx *= -COLLISION_RESTITUTION * 0.8;
                     }
                 }
            }
            function circleCollision(c1, c2) { /* ... (bez zmian) ... */
                 if (!c1 || !c2) return false; const dx = c1.x - c2.x; const dy = c1.y - c2.y; const distance = Math.hypot(dx, dy); const radiiSum = c1.radius + c2.radius; return distance < radiiSum;
             }
            function resolveCollision(obj1, obj2) {
                 if (!obj1 || !obj2) return;
                 const dx = obj2.x - obj1.x;
                 const dy = obj2.y - obj1.y;
                 const distance = Math.hypot(dx, dy);
                 const radiiSum = obj1.radius + obj2.radius;
                 const overlap = radiiSum - distance;

                 if (overlap > 0 && distance > 0.01) { // Unikamy dzielenia przez zero
                     const nx = dx / distance; // Wektor normalny X
                     const ny = dy / distance; // Wektor normalny Y

                     // Przesunięcie, aby się nie przenikały
                     const moveCorrection = overlap / 2;
                     obj1.x -= nx * moveCorrection; obj1.y -= ny * moveCorrection;
                     obj2.x += nx * moveCorrection; obj2.y += ny * moveCorrection;

                     // Względna prędkość
                     const dvx = obj1.vx - obj2.vx;
                     const dvy = obj1.vy - obj2.vy;

                     // Iloczyn skalarny (prędkość w kierunku normalnym)
                     const dotProduct = dvx * nx + dvy * ny;

                     // Zderzenie tylko jeśli się zbliżają
                     if (dotProduct < 0) {
                          // Współczynnik restytucji
                          let restitution = COLLISION_RESTITUTION;
                          // Inna restytucja dla zderzeń gracz-gracz
                          if (obj1 !== ball && obj2 !== ball) {
                              restitution = PLAYER_COLLISION_RESTITUTION;
                          }

                         // Masa (uproszczona - piłka lżejsza)
                         const mass1 = (obj1 === ball) ? 0.5 : 1.0;
                         const mass2 = (obj2 === ball) ? 0.5 : 1.0;
                         const invMassSum = (1 / mass1) + (1 / mass2);

                         // Impuls
                         let impulse = (-(1 + restitution) * dotProduct) / invMassSum;

                         // Zastosowanie impulsu
                         obj1.vx += (impulse / mass1) * nx;
                         obj1.vy += (impulse / mass1) * ny;
                         obj2.vx -= (impulse / mass2) * nx;
                         obj2.vy -= (impulse / mass2) * ny;

                         // Dodatkowy boost dla piłki po zderzeniu z graczem
                         if (obj1 === ball) { ball.vx *= BALL_COLLISION_BOOST; ball.vy *= BALL_COLLISION_BOOST; }
                         if (obj2 === ball) { ball.vx *= BALL_COLLISION_BOOST; ball.vy *= BALL_COLLISION_BOOST; }
                     }
                 }
            }
            function checkCollisions() {
                 if (!ball) return;
                 const allPlayers = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway].filter(p => p); // Filtruj null/undefined
                 const allObjects = [...allPlayers, ball];

                 // Sprawdzanie kolizji każdy z każdym
                 for (let i = 0; i < allObjects.length; i++) {
                     for (let j = i + 1; j < allObjects.length; j++) {
                         if (circleCollision(allObjects[i], allObjects[j])) {
                             resolveCollision(allObjects[i], allObjects[j]);
                         }
                     }
                 }
            }

            // --- SZTUCZNA INTELIGENCJA (AI) ---
            function aiMove() {
                if (!ball || !goalkeeperAway || fieldPlayersAway.length === 0) return;

                const defendLineX = canvas.width * 0.65; // Linia obrony AI

                // --- Logika Bramkarza AI (niezależna) ---
                let targetGkY = ball.y;
                // Ogranicz cel Y do obszaru bramki
                 const goalTopLimit = canvas.height / 2 - 50 + goalkeeperAway.radius;
                 const goalBottomLimit = canvas.height / 2 + 50 - goalkeeperAway.radius;
                 targetGkY = Math.max(goalTopLimit, Math.min(goalBottomLimit, targetGkY));

                 let dyGK = targetGkY - goalkeeperAway.y;
                 // Ruszaj się tylko jeśli piłka jest blisko lub na połowie AI i jest potrzeba ruchu
                 let gkShouldMove = Math.abs(dyGK) > goalkeeperAway.radius * 0.5 && ball.x > canvas.width * 0.4;
                 if (gkShouldMove) {
                     goalkeeperAway.vy = Math.sign(dyGK) * AI_GOALKEEPER_SPEED;
                 } else {
                     goalkeeperAway.vy *= 0.8; // Zwalniaj jeśli nie musi się ruszać
                 }
                 // Proste pozycjonowanie poziome - staraj się być na linii strzału
                 let targetGkX = canvas.width - 50; // Domyślna pozycja X
                 if (ball.x > canvas.width * 0.6) { // Jeśli piłka jest bliżej bramki AI
                      // Staraj się być między piłką a środkiem bramki
                      targetGkX = goalkeeperAway.x + (ball.x - goalkeeperAway.x) * 0.05;
                 }
                 targetGkX = Math.max(canvas.width / 2 + 50, targetGkX); // Nie przekraczaj połowy
                 let dxGK = targetGkX - goalkeeperAway.x;
                  if (Math.abs(dxGK) > 5 && gkShouldMove) {
                      goalkeeperAway.vx = Math.sign(dxGK) * AI_GOALKEEPER_SPEED * 0.3; // Wolniejszy ruch poziomy
                  } else {
                      goalkeeperAway.vx *= 0.8;
                  }


                // --- Logika Zawodników z Pola AI ---
                let closestPlayerIndex = -1;
                let minDistSq = Infinity;

                // 1. Znajdź najbliższego zawodnika AI do piłki
                fieldPlayersAway.forEach((player, index) => {
                    let dx = ball.x - player.x;
                    let dy = ball.y - player.y;
                    let distSq = dx * dx + dy * dy;
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closestPlayerIndex = index;
                    }
                });

                // 2. Wykonaj ruchy dla każdego zawodnika AI
                fieldPlayersAway.forEach((player, index) => {
                    let targetX, targetY;
                    let currentSpeed = Math.hypot(player.vx, player.vy);
                    let maxSpeed;
                    let aiImpulse;

                    if (index === closestPlayerIndex) {
                        // **Aktywny ruch:** Najbliższy zawodnik idzie do piłki
                        targetX = ball.x;
                        targetY = ball.y;
                        aiImpulse = AI_ACTIVE_SPEED;
                        maxSpeed = MAX_AI_PLAYER_SPEED;

                    } else {
                        // **Pasywny ruch:** Pozostali wracają na pozycje obronne
                        // Prosta logika powrotu - celuj w swoją "ćwiartkę" za linią obrony
                        targetX = defendLineX + 40 + (Math.random() - 0.5) * 80; // Rozproszenie za linią obrony
                        let side = (index % 2 === 0) ? -1 : 1; // Rozdziel ich na boki
                        targetY = canvas.height / 2 + side * canvas.height * 0.25 + (Math.random() - 0.5) * 50;
                        aiImpulse = AI_PASSIVE_SPEED;
                        maxSpeed = MAX_AI_PASSIVE_SPEED;
                    }

                    // Oblicz wektor do celu
                    let dxToTarget = targetX - player.x;
                    let dyToTarget = targetY - player.y;
                    let distToTarget = Math.hypot(dxToTarget, dyToTarget);

                    if (distToTarget > player.radius) { // Ruszaj się tylko jeśli nie jesteś na celu
                        // Zastosuj impuls w kierunku celu
                        player.vx += (dxToTarget / distToTarget) * aiImpulse * (distToTarget > 50 ? 1 : distToTarget/50) ; // Zmniejsz siłę blisko celu
                        player.vy += (dyToTarget / distToTarget) * aiImpulse * (distToTarget > 50 ? 1 : distToTarget/50) ;

                        // Ogranicz maksymalną prędkość
                        if (currentSpeed > maxSpeed) {
                            player.vx = (player.vx / currentSpeed) * maxSpeed;
                            player.vy = (player.vy / currentSpeed) * maxSpeed;
                        }
                    }

                    // Proste unikanie kolegów z drużyny (słabe)
                    fieldPlayersAway.forEach(other => {
                        if (player !== other) {
                            let dXOther = other.x - player.x;
                            let dYOther = other.y - player.y;
                            let distOther = Math.hypot(dXOther, dYOther);
                            if (distOther < player.radius * 3 && distOther > 0) {
                                player.vx -= (dXOther / distOther) * 0.02; // Bardzo słabe odpychanie
                                player.vy -= (dYOther / distOther) * 0.02;
                            }
                        }
                    });
                });
            }


            // --- PĘTLA GŁÓWNA GRY ---
            function gameLoop() {
                if (!gameAnimating || !ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawField();
                updatePositions();
                checkCollisions();
                // aiMove(); // Ruch AI jest teraz wywoływany w canvasMouseUp
                drawGameObjects();
                requestAnimationFrame(gameLoop);
            }

            // --- OBSŁUGA MYSZY (PRZECIĄGANIE) ---
            function canvasMouseDown(e) { /* ... (bez zmian) ... */
                 if (!canvas) return; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
                 for (let i = 0; i < fieldPlayers.length; i++) { const p = fieldPlayers[i]; if (p && Math.hypot(mx - p.x, my - p.y) < p.radius + 5) { draggingPlayerIndex = i; isDragging = true; dragStart = { x: p.x, y: p.y }; dragCurrent = { x: mx, y: my }; canvas.style.cursor = 'grabbing'; return; } }
                 if (goalkeeper && Math.hypot(mx - goalkeeper.x, my - goalkeeper.y) < goalkeeper.radius + 5) { draggingPlayerIndex = -1; isDragging = true; dragStart = { x: goalkeeper.x, y: goalkeeper.y }; dragCurrent = { x: mx, y: my }; canvas.style.cursor = 'grabbing'; return; }
            }
            function canvasMouseMove(e) { /* ... (bez zmian) ... */
                 if (!isDragging || !canvas) return; const rect = canvas.getBoundingClientRect(); dragCurrent.x = e.clientX - rect.left; dragCurrent.y = e.clientY - rect.top;
            }
            function canvasMouseUp(e) {
                 if (!isDragging || draggingPlayerIndex === null || !canvas) return;

                 const dx = dragStart.x - dragCurrent.x;
                 const dy = dragStart.y - dragCurrent.y;
                 let pullLength = Math.hypot(dx, dy);
                 let pullScale = Math.min(1, pullLength / MAX_PULL_LENGTH);

                 const impulseX = (dx / (pullLength || 1)) * pullLength * DRAG_IMPULSE_SCALE * pullScale;
                 const impulseY = (dy / (pullLength || 1)) * pullLength * DRAG_IMPULSE_SCALE * pullScale;

                 if (draggingPlayerIndex >= 0 && fieldPlayers[draggingPlayerIndex]) {
                     fieldPlayers[draggingPlayerIndex].vx = impulseX;
                     fieldPlayers[draggingPlayerIndex].vy = impulseY;
                 } else if (draggingPlayerIndex === -1 && goalkeeper) {
                      goalkeeper.vx = impulseX * 0.8;
                      goalkeeper.vy = impulseY * 0.8;
                 }

                 isDragging = false;
                 draggingPlayerIndex = null;
                 canvas.style.cursor = 'grab';

                 // Wywołaj ruch AI *po* ruchu gracza
                 aiMove();
            }
            function canvasMouseLeave(e) { /* ... (bez zmian) ... */
                if (isDragging) { isDragging = false; draggingPlayerIndex = null; if (canvas) canvas.style.cursor = 'grab'; }
            }
            function addCanvasEvents() { /* ... (bez zmian) ... */
                 if (!canvas) return; canvas.addEventListener("mousedown", canvasMouseDown); canvas.addEventListener("mousemove", canvasMouseMove); canvas.addEventListener("mouseup", canvasMouseUp); canvas.addEventListener("mouseleave", canvasMouseLeave);
            }

            // --- WYBÓR DRUŻYN ---
            function populateTeamSelections() { /* ... (bez zmian, jak w poprzedniej wersji) ... */
                 const homeContainer = document.getElementById("homeTeamContainer"); const awayContainer = document.getElementById("awayTeamContainer"); if (!homeContainer || !awayContainer) return; homeContainer.innerHTML = ""; awayContainer.innerHTML = ""; selectedHomeTeam = null; selectedAwayTeam = null;
                 Object.keys(teamsData).forEach(league => {
                     const leagueData = teamsData[league];
                     const createLeagueSection = (targetContainer, isHome) => {
                         let leagueDiv = document.createElement("div"); leagueDiv.className = "league-section";
                         let leagueHeader = document.createElement("div"); leagueHeader.className = "league-header"; let leagueLogo = document.createElement("img"); leagueLogo.src = leagueData.leagueLogo; leagueLogo.alt = league; let leagueName = document.createElement("span"); leagueName.innerText = league; leagueHeader.appendChild(leagueLogo); leagueHeader.appendChild(leagueName); leagueDiv.appendChild(leagueHeader);
                         let teamInnerContainer = document.createElement("div"); teamInnerContainer.style.display = "flex"; teamInnerContainer.style.gap = "15px"; // Użyj flex dla lepszego układu
                         leagueData.teams.forEach(team => {
                             let teamDiv = document.createElement("div"); teamDiv.className = "team-option"; teamDiv.dataset.team = team.name; teamDiv.innerHTML = `<img src="${team.logo}" alt="${team.name}" /><p>${team.name}</p>`;
                             teamDiv.addEventListener("click", function () {
                                 Array.from(targetContainer.querySelectorAll('.team-option.selected')).forEach(el => el.classList.remove("selected")); this.classList.add("selected");
                                 if (isHome) selectedHomeTeam = team.name; else selectedAwayTeam = team.name;
                             });
                             teamInnerContainer.appendChild(teamDiv); // Dodaj do wewnętrznego kontenera
                         });
                         leagueDiv.appendChild(teamInnerContainer); targetContainer.appendChild(leagueDiv);
                     };
                     createLeagueSection(homeContainer, true); createLeagueSection(awayContainer, false);
                 });
            }

            // --- FUNKCJE USTAWIEŃ (Rozmiar czcionki) ---
            const fontSizeOptions = document.querySelectorAll('.fontSizeOption');
            function applyFontSize(size) { /* ... (bez zmian) ... */
                 if (!['small', 'medium', 'large'].includes(size)) { size = 'medium'; } document.body.classList.remove('font-size-small', 'font-size-medium', 'font-size-large'); document.body.classList.add(`font-size-${size}`); localStorage.setItem('gameFontSize', size);
                 fontSizeOptions.forEach(button => { if (button) { button.classList.remove('active-size'); if (button.dataset.size === size) { button.classList.add('active-size'); } } }); console.log("Zastosowano rozmiar czcionki:", size);
            }
            function loadFontSize() { /* ... (bez zmian) ... */
                const savedSize = localStorage.getItem('gameFontSize') || 'medium'; applyFontSize(savedSize);
            }

             // --- FUNKCJE POMOCNICZE MODALI ---
             function openModal(modalElement) { /* ... (bez zmian) ... */
                 if(modalElement) modalElement.classList.remove('hidden');
             }
              function closeModal(modalElement) { /* ... (bez zmian) ... */
                 if(modalElement) modalElement.classList.add('hidden');
             }

            // --- GŁÓWNA INICJALIZACJA (DOMContentLoaded) ---
            document.addEventListener("DOMContentLoaded", () => {
                loadFontSize(); // Wczytaj ustawienia

                // Przypisanie Event Listenerów dla przycisków nawigacji i modali
                const startMatchBtn = document.getElementById("startMatchBtn");
                const startMatchFromSelectBtn = document.getElementById("startMatchFromSelectBtn");
                const backToStartBtn = document.getElementById("backToStartBtn");
                const btnPlayerDB = document.getElementById("btnPlayerDB");
                const btnLanguage = document.getElementById("btnLanguage");
                const btnSettings = document.getElementById("btnSettings");
                const closePlayerDBBtn = document.getElementById("closePlayerDBBtn");
                const closeLanguageModalBtn = document.getElementById("closeLanguageModalBtn");
                const closeSettingsModalBtn = document.getElementById("closeSettingsModalBtn");
                const addPlayerForm = document.getElementById("addPlayerForm");
                const langOptions = document.querySelectorAll(".langOption");

                if (startMatchBtn) startMatchBtn.addEventListener("click", () => { closeModal(startScreen); openModal(teamSelectScreen); populateTeamSelections(); });
                if (startMatchFromSelectBtn) startMatchFromSelectBtn.addEventListener("click", () => {
                     if (!selectedHomeTeam || !selectedAwayTeam) { alert("Proszę wybrać obie drużyny!"); return; }
                     if (selectedHomeTeam === selectedAwayTeam) { alert("Drużyny muszą być różne!"); return; }
                     closeModal(teamSelectScreen); openModal(gameScreen);
                     initGame(); addCanvasEvents(); startTimer(); gameAnimating = true; requestAnimationFrame(gameLoop);
                });
                if (backToStartBtn) backToStartBtn.addEventListener("click", () => { gameAnimating = false; stopTimer(); closeModal(gameScreen); openModal(startScreen); resetGameFull(); });

                if(btnPlayerDB) btnPlayerDB.addEventListener("click", () => openModal(playerDBModal));
                if(btnLanguage) btnLanguage.addEventListener("click", () => openModal(languageModal));
                if(btnSettings) btnSettings.addEventListener("click", () => {
                     openModal(settingsModal); const currentSize = localStorage.getItem('gameFontSize') || 'medium';
                     fontSizeOptions.forEach(button => { if(button) button.classList.toggle('active-size', button.dataset.size === currentSize); });
                });

                if(closePlayerDBBtn) closePlayerDBBtn.addEventListener("click", () => closeModal(playerDBModal));
                if(closeLanguageModalBtn) closeLanguageModalBtn.addEventListener("click", () => closeModal(languageModal));
                if(closeSettingsModalBtn) closeSettingsModalBtn.addEventListener("click", () => closeModal(settingsModal));

                fontSizeOptions.forEach(button => { if(button) button.addEventListener('click', () => applyFontSize(button.dataset.size)); });

                if(addPlayerForm) addPlayerForm.addEventListener("submit", (e) => { /* ... (logika dodawania gracza, bez zmian) ... */
                    e.preventDefault(); const name = document.getElementById("playerName")?.value; const team = document.getElementById("playerTeam")?.value; const rating = document.getElementById("playerRating")?.value;
                     if(name && team && rating){ console.log("Dodawanie gracza:", { name, team, rating }); const playerListDiv = document.getElementById("playerList"); if(playerListDiv){ const newPlayerEntry = document.createElement('p'); newPlayerEntry.textContent = `${name} (${team}) - Ocena: ${rating}`; playerListDiv.appendChild(newPlayerEntry); } e.target.reset(); } else { console.warn("Formularz dodawania gracza: brakuje danych"); }
                });
                langOptions.forEach(button => { if(button) button.addEventListener("click", () => { const lang = button.dataset.lang; console.log("Zmieniono język na:", lang); /* logika zmiany języka */ closeModal(languageModal); }); });

                console.log("MiniSoccer v2 gotowe!");
            });

        })();
    </script>
</body>
</html>
