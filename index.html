<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MiniSoccer - Szybki Mecz</title>
    <!-- Łącze do czcionki Nunito -->
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* GLOBALNE STYLE – DESIGN W PIŁKARSKIM KLIMACIE */
      /* Tło zmienione na zdjęcie stadionu */
      body {
        font-family: "Nunito", sans-serif;
        background: url("https://images.unsplash.com/photo-1578985545062-69928b1d9587?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80")
          no-repeat center center fixed;
        background-size: cover;
        margin: 0;
        padding: 0;
        text-align: center;
        color: #fff;
      }
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.3);
        z-index: -1;
      }
      .hidden { display: none !important; }

      /* EKRAN STARTOWY */
      #startScreen {
        padding: 40px 20px;
      }
      #startScreen h1 {
        font-size: 56px;
        margin-bottom: 30px;
        text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      }
      #startScreen button {
        font-size: 20px;
        padding: 15px 30px;
        margin: 15px;
        border: none;
        border-radius: 10px;
        background-color: rgba(255,255,255,0.8);
        cursor: pointer;
        color: #333;
        box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
      }
      #startScreen button:hover {
        background-color: #fff;
        transform: scale(1.05);
        box-shadow: 0px 5px 15px rgba(0,0,0,0.3);
      }
       .start-options button { /* Style dla mniejszych przycisków opcji */
        font-size: 16px;
        padding: 10px 20px;
        margin: 5px;
      }

      /* EKRAN WYBORU DRUŻYN */
      #teamSelectScreen { padding: 40px 20px; max-width: 900px; margin: auto;} /* Ograniczenie szerokości */
      #teamSelectScreen h2 {
        font-size: 40px;
        margin-bottom: 20px;
        text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
      }
      .team-section {
        margin: 30px auto;
        text-align: left;
        background-color: rgba(0, 0, 0, 0.2); /* Lekkie tło dla sekcji */
        padding: 15px;
        border-radius: 10px;
      }
      .team-section h3 { font-size: 28px; margin-bottom: 15px; padding-left: 10px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 5px;}
      .team-container { /* Zmienione na team-container, a nie team-row */
        display: block; /* Każda liga w nowej linii */
        margin-bottom: 20px; /* Odstęp między ligami */
      }
       .league-header { /* Zmieniony styl nagłówka ligi */
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        padding-left: 10px;
        font-size: 20px; /* Większa czcionka ligi */
        font-weight: bold;
      }
      .league-header img { width: 30px; height: auto; } /* Dostosowanie logo ligi */

      .team-row { /* Kontener dla drużyn w danej lidze */
        display: flex;
        gap: 15px; /* Odstęp między drużynami */
        overflow-x: auto; /* Przewijanie poziome dla drużyn */
        padding: 10px 0; /* Padding góra/dół */
        scrollbar-width: thin; /* Styl paska przewijania */
        scrollbar-color: #ffd700 rgba(255,255,255,0.1);
      }

       .team-row::-webkit-scrollbar { height: 8px; }
      .team-row::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 4px;}
      .team-row::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 4px;}


      .team-option {
        cursor: pointer;
        text-align: center;
        border: 3px solid rgba(255,255,255,0.5);
        border-radius: 12px;
        width: 140px; /* Stała szerokość */
        padding: 10px;
        transition: all 0.3s ease;
        flex: 0 0 140px; /* Zapobiega rozciąganiu */
        background-color: rgba(255,255,255, 0.1);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      .team-option:hover {
          border-color: #fff;
          background-color: rgba(255,255,255, 0.2);
      }
      .team-option.selected {
        border-color: #ffd700; /* Złota ramka dla wybranej drużyny */
        transform: scale(1.05); /* Lekkie powiększenie */
        background-color: rgba(255, 215, 0, 0.3); /* Złote tło dla wybranej */
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      }
      .team-option img {
        width: 70px; /* Zmniejszone logo */
        height: 70px;
        display: block;
        margin: 5px auto 10px;
        object-fit: contain; /* Zapobiega zniekształceniom */
      }
      .team-option p {
          font-size: 14px; /* Mniejsza nazwa drużyny */
          margin: 0;
          min-height: 2.5em; /* Zapewnia miejsce na 2 linie tekstu */
          display: flex;
          align-items: center;
          justify-content: center;
      }
      #startMatchFromSelectBtn {
        font-size: 20px;
        padding: 15px 30px;
        margin-top: 30px;
        cursor: pointer;
        background-color: #ffd700; /* Złoty przycisk */
        color: #333;
        border: none;
        border-radius: 12px;
        transition: all 0.3s ease;
        box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
        font-weight: bold;
      }
      #startMatchFromSelectBtn:hover {
        background-color: #fff;
        transform: scale(1.05);
        box-shadow: 0px 5px 15px rgba(0,0,0,0.3);
      }
       #startMatchFromSelectBtn:disabled { /* Styl dla nieaktywnego przycisku */
         background-color: #aaa;
         cursor: not-allowed;
         opacity: 0.7;
       }

      /* EKRAN GRY */
      #gameScreen { padding: 20px; }
      #scoreboardContainer {
          margin-bottom: 15px;
          background-color: rgba(0, 0, 0, 0.5);
          padding: 10px;
          border-radius: 8px;
          display: inline-block; /* Dopasuj szerokość do zawartości */
       }
      #scoreboard { font-size: 28px; font-weight: bold; margin: 0 0 5px 0; }
      #matchTimer { font-size: 20px; margin: 0; }
      canvas {
        background-color: #1E8449; /* Ciemniejszy zielony */
        border: 4px solid #fff;
        border-radius: 16px;
        display: block;
        margin: 0 auto;
        box-shadow: 0px 8px 16px rgba(0,0,0,0.35);
      }
      #backToStartBtn {
        font-size: 18px;
        padding: 12px 25px; /* Trochę mniejszy */
        margin-top: 20px;
        cursor: pointer;
        background: rgba(255,255,255,0.9);
        color: #333;
        border: none;
        border-radius: 10px;
        transition: background 0.3s;
        box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
      }
      #backToStartBtn:hover { background: rgba(255,255,255,1); }

      /* MODALE */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7); /* Ciemniejsze tło modala */
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        animation: fadeIn 0.3s;
      }
      @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
      .modal-content {
        background: #f0f0f0; /* Jaśniejsze tło zawartości modala */
        padding: 30px;
        width: 90%;
        max-width: 500px;
        border-radius: 16px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.35);
        color: #333; /* Ciemny tekst w modalu */
      }
      .modal-content h2 { margin-top: 0; font-size: 28px; color: #1a6a35; } /* Zielony nagłówek */
      .modal-content button {
        background: #1a6a35; /* Zielony przycisk */
        color: white;
        border: none;
        border-radius: 6px;
        padding: 10px 20px;
        margin: 10px 5px 0 5px; /* Odstępy */
        transition: background 0.3s, transform 0.2s;
        box-shadow: 0px 2px 4px rgba(0,0,0,0.25);
        cursor: pointer;
        font-size: 16px;
      }
      .modal-content button:hover {
        background: #228B22; /* Jaśniejszy zielony */
        transform: translateY(-2px);
      }
       .modal-content button.close-btn { /* Styl dla przycisku zamknięcia */
            background-color: #aaa;
       }
        .modal-content button.close-btn:hover {
             background-color: #888;
        }
      input {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 10px;
        margin: 8px 0; /* Większy margines */
        width: calc(100% - 22px); /* Poprawka szerokości uwzględniająca padding */
        box-sizing: border-box;
        font-size: 16px;
      }
      #playerList {
        max-height: 250px; /* Zmniejszona wysokość listy */
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #185c28 #e0e0e0; /* Kolory paska */
        border: 1px solid #ccc; /* Ramka listy */
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 15px;
        background-color: #fff; /* Białe tło listy */
      }
      #playerList::-webkit-scrollbar { width: 8px; }
      #playerList::-webkit-scrollbar-thumb { background: #185c28; border-radius: 5px; }
      #playerList::-webkit-scrollbar-track { background: #e0e0e0; border-radius: 5px;}

      /* Poprawki dla urządzeń mobilnych */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 40px; }
            #startScreen button { font-size: 18px; padding: 12px 25px; }
            .start-options button { font-size: 14px; padding: 8px 15px; }
            #teamSelectScreen h2 { font-size: 30px; }
            .team-section h3 { font-size: 22px; }
            .league-header { font-size: 18px; }
            .team-option { width: 110px; flex-basis: 110px; }
            .team-option img { width: 50px; height: 50px; }
            .team-option p { font-size: 12px; min-height: 2em;}
            canvas { width: 95%; height: auto; } /* Dopasuj canvas do szerokości */
            #scoreboard { font-size: 22px; }
            #matchTimer { font-size: 16px; }
            #backToStartBtn { font-size: 16px; padding: 10px 20px;}
            .modal-content { padding: 20px; }
            .modal-content h2 { font-size: 24px;}
        }

    </style>
  </head>
  <body>
    <!-- EKRAN STARTOWY -->
    <div id="startScreen">
      <h1>MiniSoccer ⚽</h1>
      <button id="startMatchBtn">SZYBKI MECZ</button>
      <div class="start-options">
        <!-- Przyciski opcji (na razie bez funkcjonalności) -->
        <button id="btnPlayerDB" disabled title="Funkcja niedostępna">Baza zawodników</button>
        <button id="btnLanguage" disabled title="Funkcja niedostępna">Język</button>
        <button id="btnSettings" disabled title="Funkcja niedostępna">Ustawienia</button>
      </div>
    </div>

    <!-- EKRAN WYBORU DRUŻYN -->
    <div id="teamSelectScreen" class="hidden">
      <h2>Wybierz Drużyny</h2>
      <div class="team-section" id="homeTeamSection">
        <h3>Drużyna Domowa <span id="selectedHomeTeamName"></span></h3>
        <div id="homeTeamContainer" class="team-container">
            <!-- Drużyny będą dodane przez JS -->
        </div>
      </div>
      <div class="team-section" id="awayTeamSection">
        <h3>Drużyna Gościa <span id="selectedAwayTeamName"></span></h3>
        <div id="awayTeamContainer" class="team-container">
            <!-- Drużyny będą dodane przez JS -->
        </div>
      </div>
      <button id="startMatchFromSelectBtn" disabled>Rozpocznij Mecz</button> <!-- Początkowo nieaktywny -->
    </div>

    <!-- EKRAN GRY -->
    <div id="gameScreen" class="hidden">
      <div id="scoreboardContainer">
        <h2 id="scoreboard">— : —</h2>
        <h3 id="matchTimer">Czas: 3:00</h3>
      </div>
      <canvas id="gameCanvas" width="800" height="500"></canvas>
      <button id="backToStartBtn">Powrót do Menu</button>
    </div>

    <!-- MODALE (opcjonalnie, teraz nieużywane aktywnie) -->
    <div id="playerDBModal" class="modal hidden">
      <div class="modal-content">
        <h2>Baza zawodników</h2>
        <div id="playerList"></div>
        <h3>Dodaj zawodnika</h3>
        <form id="addPlayerForm">
          <input type="text" id="playerName" placeholder="Imię i nazwisko" required />
          <input type="text" id="playerTeam" placeholder="Drużyna" required />
          <input type="number" id="playerRating" placeholder="Ocena" required min="0" max="100" />
          <button type="submit">Dodaj</button>
        </form>
        <button id="closePlayerDBBtn" class="close-btn">Zamknij</button>
      </div>
    </div>

    <div id="languageModal" class="modal hidden">
      <div class="modal-content">
        <h2>Wybór języka</h2>
        <p>Wybierz język interfejsu:</p>
        <button class="langOption" data-lang="pl">Polski</button>
        <button class="langOption" data-lang="en">English</button>
        <button id="closeLanguageModalBtn" class="close-btn">Zamknij</button>
      </div>
    </div>

    <!-- ###################################################### -->
    <!-- ###### TUTAJ UMIEŚĆ ELEMENT AUDIO DLA MUZYKI ###### -->
    <!-- ###### (Najlepiej tuż przed zamknięciem </body>) ###### -->
    <!-- ###################################################### -->
    <audio id="backgroundMusic" loop>
      <!--
        WAŻNE: Zmień 'path/to/your/music.mp3' poniżej na właściwą ścieżkę do Twojego pliku.
        Przykłady:
          - Jeśli plik 'muzyka.mp3' jest w tym samym folderze co ten plik HTML:
            src="muzyka.mp3"
          - Jeśli plik 'muzyka.mp3' jest w podfolderze 'audio':
            src="audio/muzyka.mp3"
      -->
      <source src="path/to/your/music.mp3" type="audio/mpeg">
      <!-- Możesz dodać więcej formatów dla lepszej kompatybilności -->
      <!-- <source src="path/to/your/music.ogg" type="audio/ogg"> -->
      Twoja przeglądarka nie obsługuje elementu audio.
    </audio>
    <!-- ###################################################### -->
    <!-- ###### KONIEC SEKCJI AUDIO                      ###### -->
    <!-- ###################################################### -->


    <script>
      (function () {
        "use strict";

        // GLOBALNE ZMIENNE I KONSTANTY
        let score = { home: 0, away: 0 };
        let canvas, ctx, ball;
        let fieldPlayers = [];      // Zawodnicy drużyny domowej (gracz)
        let fieldPlayersAway = [];  // Zawodnicy drużyny przeciwnej (AI)
        let goalkeeper, goalkeeperAway;  // Bramkarze
        let gameAnimating = false;
        let isDragging = false, draggingPlayerIndex = null; // -1 dla bramkarza, >= 0 dla gracza z pola
        let dragStart = { x: 0, y: 0 },
            dragCurrent = { x: 0, y: 0 };
        let selectedHomeTeam = null, selectedAwayTeam = null;

        const PLAYER_RADIUS = 16,
              GOALKEEPER_RADIUS = 18,
              BALL_RADIUS = 8,
              FRICTION = 0.98, // Tarcie ogólne
              BALL_FRICTION = 0.99, // Dodatkowe tarcie dla piłki
              PLAYER_COLLISION_FRICTION = 0.9, // Tarcie przy zderzeniach między graczami
              WALL_RESTITUTION = 0.5, // Sprężystość odbicia od ścian
              PLAYER_RESTITUTION = 0.6, // Sprężystość odbicia gracz-gracz / gracz-piłka
              DRAG_IMPULSE_SCALE = 0.08, // Skala siły "strzału" przy przeciąganiu
              MAX_PLAYER_SPEED = 5; // Maksymalna prędkość zawodnika

        // === REFERENCJA DO ELEMENTU AUDIO ===
        const backgroundMusic = document.getElementById('backgroundMusic');
        // Referencje do przycisków i elementów UI
        const startMatchFromSelectBtn = document.getElementById('startMatchFromSelectBtn');
        const selectedHomeTeamNameSpan = document.getElementById('selectedHomeTeamName');
        const selectedAwayTeamNameSpan = document.getElementById('selectedAwayTeamName');


        // CZAS MECZU – MATCH_DURATION = 180 sekund (3:00)
        const MATCH_DURATION = 180;
        let matchTime = MATCH_DURATION;
        let matchTimerInterval = null;

        function formatTime(seconds) {
            let minutes = Math.floor(seconds / 60);
            let secs = seconds % 60;
            if (secs < 10) secs = "0" + secs;
            return minutes + ":" + secs;
        }

        function updateTimerDisplay() {
          document.getElementById("matchTimer").innerText = "Czas: " + formatTime(matchTime);
        }

        function startTimer() {
          matchTime = MATCH_DURATION;
          updateTimerDisplay();
          // Zatrzymaj poprzedni timer, jeśli istnieje
          if (matchTimerInterval) clearInterval(matchTimerInterval);
          matchTimerInterval = setInterval(() => {
            matchTime--;
            updateTimerDisplay();
            if (matchTime <= 0) {
              gameOver();
            }
          }, 1000);
        }

        function stopTimer() {
          clearInterval(matchTimerInterval);
          matchTimerInterval = null;
        }

        function gameOver() {
          stopTimer();
          gameAnimating = false;
          // === ZATRZYMAJ MUZYKĘ ===
          if (backgroundMusic) {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; // Resetuj czas odtwarzania
          }
          // Użyj setTimeout, aby alert pojawił się po ostatniej klatce renderowania
          setTimeout(() => {
            alert("Koniec meczu! Wynik:\n" + selectedHomeTeam + " " + score.home + " : " + score.away + " " + selectedAwayTeam);
             // Resetuj stan gry i wróć do menu
             resetGameToMenu();
          }, 100); // Krótkie opóźnienie
        }

        function resetGameToMenu() {
            // Ukryj ekran gry, pokaż ekran startowy
            document.getElementById("gameScreen").classList.add("hidden");
            document.getElementById("startScreen").classList.remove("hidden");
            // Resetuj wybór drużyn
            selectedHomeTeam = null;
            selectedAwayTeam = null;
            selectedHomeTeamNameSpan.textContent = "";
            selectedAwayTeamNameSpan.textContent = "";
            startMatchFromSelectBtn.disabled = true;
             // Zresetuj również zaznaczenie w opcjach wyboru drużyn (jeśli ekran wyboru jest nadal w DOM)
            const teamOptions = document.querySelectorAll('#teamSelectScreen .team-option');
            teamOptions.forEach(opt => opt.classList.remove('selected'));
        }

        // BAZA DANYCH KLUBÓW – oryginalna
        const teamsData = {
          "Premier League": {
            leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/f2/Premier_League_Logo.svg",
            teams: [
              { name: "Man United", logo: "https://upload.wikimedia.org/wikipedia/en/7/7a/Manchester_United_FC_crest.svg" },
              { name: "Man City", logo: "https://upload.wikimedia.org/wikipedia/en/e/eb/Manchester_City_FC_badge.svg" },
              { name: "Liverpool", logo: "https://upload.wikimedia.org/wikipedia/en/0/0c/Liverpool_FC.svg" },
              { name: "Chelsea", logo: "https://upload.wikimedia.org/wikipedia/en/c/cc/Chelsea_FC.svg" },
              { name: "Arsenal", logo: "https://upload.wikimedia.org/wikipedia/en/5/53/Arsenal_FC.svg" },
              { name: "Tottenham", logo: "https://upload.wikimedia.org/wikipedia/en/b/b4/Tottenham_Hotspur.svg" }
            ]
          },
          "La Liga": {
            leagueLogo: "https://upload.wikimedia.org/wikipedia/en/9/90/LaLiga.svg",
            teams: [
              { name: "Real Madrid", logo: "https://upload.wikimedia.org/wikipedia/en/5/56/Real_Madrid_CF.svg" },
              { name: "Barcelona", logo: "https://upload.wikimedia.org/wikipedia/en/4/47/FC_Barcelona_%28crest%29.svg" },
              { name: "Atletico", logo: "https://brandlogos.net/wp-content/uploads/2021/09/atltico-madrid-logo.png" },
              { name: "Sevilla", logo: "https://cdn.freebiesupply.com/logos/large/2x/sevilla-fc-logo-png-transparent.png" },
              { name: "Valencia", logo: "https://brandlogos.net/wp-content/uploads/2014/10/valencia_cf-logo_brandlogos.net_iaffl-512x674.png" },
              { name: "Villarreal", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Villarreal_CF_logo-en.svg/1200px-Villarreal_CF_logo-en.svg.png" }
            ]
          },
          "Serie A": {
            leagueLogo: "https://upload.wikimedia.org/wikipedia/en/d/d2/Serie_A_logo_(2019).svg",
            teams: [
              { name: "Juventus", logo: "https://upload.wikimedia.org/wikipedia/commons/d/da/Juventus_Logo.png" },
              { name: "Inter", logo: "https://upload.wikimedia.org/wikipedia/commons/0/05/FC_Internazionale_Milano_2021.svg" },
              { name: "AC Milan", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Logo_of_AC_Milan.svg/653px-Logo_of_AC_Milan.svg.png" },
              { name: "Napoli", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/SSC_Neapel.svg/1200px-SSC_Neapel.svg.png" },
              { name: "AS Roma", logo: "https://upload.wikimedia.org/wikipedia/sco/7/7d/AS_Roma%27s_logo_from_2017.png" },
              { name: "Lazio", logo: "https://static.cdnlogo.com/logos/s/89/ss-lazio.png" }
            ]
          },
          "Bundesliga": {
            leagueLogo: "https://upload.wikimedia.org/wikipedia/commons/d/df/Bundesliga_logo_(2017).svg",
            teams: [
              { name: "Bayern", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/FC_Bayern_M%C3%BCnchen_logo_(2017).svg/2048px-FC_Bayern_M%C3%BCnchen_logo_(2017).svg.png" },
              { name: "Dortmund", logo: "https://upload.wikimedia.org/wikipedia/commons/7/74/Borussia_Dortmund.png" },
              { name: "RB Leipzig", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/0/04/RB_Leipzig_2014_logo.svg/1200px-RB_Leipzig_2014_logo.svg.png" },
              { name: "Leverkusen", logo: "https://cdn.freebiesupply.com/logos/large/2x/bayer-leverkusen-logo-png-transparent.png" },
              { name: "Frankfurt", logo: "https://logodownload.org/wp-content/uploads/2019/11/eintracht-frankfurt-logo.png" },
              { name: "Gladbach", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Borussia_M%C3%B6nchengladbach_logo.svg/1200px-Borussia_M%C3%B6nchengladbach_logo.svg.png" }
            ]
          },
          "Ligue 1": {
            leagueLogo: "https://upload.wikimedia.org/wikipedia/en/f/fd/Ligue_1.svg",
            teams: [
              { name: "PSG", logo: "https://logos-world.net/wp-content/uploads/2020/07/PSG-Logo.png" },
              { name: "Marseille", logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Olympique_Marseille_logo.svg/1582px-Olympique_Marseille_logo.svg.png" },
              { name: "Lyon", logo: "https://upload.wikimedia.org/wikipedia/en/thumb/1/1c/Olympique_Lyonnais_logo.svg/1200px-Olympique_Lyonnais_logo.svg.png" },
              { name: "Monaco", logo: "https://logodownload.org/wp-content/uploads/2019/09/monaco-fc-logo-1.png" },
              { name: "Lille", logo: "https://logodownload.org/wp-content/uploads/2019/09/lille-logo-1.png" },
              { name: "Nice", logo: "https://1000logos.net/wp-content/uploads/2020/09/Nice-logo.png" }
            ]
          }
        };

        /* Funkcja pomocnicza – zwraca kolor klubowy dla danego klubu */
        function getTeamColor(teamName) {
            // Usunięto pełne nazwy, używane są skrócone z 'teamsData'
           switch(teamName) {
                // Premier League
                case "Man United": return "#DA291C"; // Czerwony
                case "Man City": return "#6CABDD";   // Błękitny
                case "Liverpool": return "#C8102E";  // Czerwony
                case "Chelsea": return "#034694";    // Niebieski
                case "Arsenal": return "#EF0107";    // Czerwony
                case "Tottenham": return "#132257";  // Granatowy (użyjemy białego jako alternatywy jeśli potrzebne)

                // La Liga
                case "Real Madrid": return "#FEBE10"; // Złoty (lub biały #FFFFFF)
                case "Barcelona": return "#A50044";  // Bordowy
                case "Atletico": return "#CB3524";   // Czerwony
                case "Sevilla": return "#F40000";    // Jasny czerwony
                case "Valencia": return "#F37021";   // Pomarańczowy
                case "Villarreal": return "#F2E300"; // Żółty

                // Serie A
                case "Juventus": return "#CCCCCC";   // Szary (lub czarny #000000)
                case "Inter": return "#0068A8";      // Niebieski
                case "AC Milan": return "#FB090B";   // Czerwony
                case "Napoli": return "#12A0D7";     // Jasnoniebieski
                case "AS Roma": return "#8E1F2F";    // Ciemnoczerwony (Giallorossi)
                case "Lazio": return "#87D8F7";      // Błękitny

                // Bundesliga
                case "Bayern": return "#DC052D";     // Czerwony
                case "Dortmund": return "#FDE100";   // Żółty
                case "RB Leipzig": return "#E6002F"; // Czerwony (lub biały #FFFFFF)
                case "Leverkusen": return "#E32221"; // Czerwony
                case "Frankfurt": return "#E1000F";  // Czerwony (lub czarny #000000)
                case "Gladbach": return "#00A450";   // Zielony

                // Ligue 1
                case "PSG": return "#004170";        // Granatowy
                case "Marseille": return "#0098D4";  // Błękitny
                case "Lyon": return "#EB1D35";       // Czerwony (lub biały #FFFFFF)
                case "Monaco": return "#EF3340";     // Czerwony
                case "Lille": return "#E01E5A";      // Czerwony
                case "Nice": return "#CC0000";       // Czerwony

                default: return "#777777"; // Domyślny szary
            }
        }

        /* FUNKCJE GRY */
        function initGame() {
          canvas = document.getElementById("gameCanvas");
          ctx = canvas.getContext("2d");

          // Ustawienie canvas na wypadek zmiany rozmiaru okna (opcjonalne)
          // canvas.width = Math.min(800, window.innerWidth * 0.9);
          // canvas.height = canvas.width * (5/8); // Utrzymaj proporcje

          ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: BALL_RADIUS,
            dx: 0, // Piłka zaczyna nieruchomo
            dy: 0,
            color: "white"
          };

          let homeColor = getTeamColor(selectedHomeTeam);
          let awayColor = getTeamColor(selectedAwayTeam);

          // Ustawienie początkowe zawodników (Formacja 2-1-1)
          fieldPlayers = [
            // Obrońcy
            { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
            { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
            // Pomocnik
            { x: canvas.width * 0.35, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
             // Napastnik
             //{ x: canvas.width * 0.40, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
          ];

          fieldPlayersAway = [
             // Obrońcy
            { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
            { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
             // Pomocnik
            { x: canvas.width * 0.65, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
             // Napastnik
             //{ x: canvas.width * 0.60, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }
          ];

          // Bramkarze
          goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor };
          goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor };

          // Reset wyniku
          score.home = 0;
          score.away = 0;
          // Zaktualizuj tablicę wyników na początku
          document.getElementById("scoreboard").innerText =
             `${selectedHomeTeam} ${score.home} : ${score.away} ${selectedAwayTeam}`;
        }

        function drawField() {
          ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; // Przezroczysta biel linii
          ctx.lineWidth = 2;

          // Linie zewnętrzne (trochę wewnątrz krawędzi canvas dla estetyki)
          const margin = 5;
          ctx.strokeRect(margin, margin, canvas.width - 2 * margin, canvas.height - 2 * margin);

          // Linia środkowa
          ctx.beginPath();
          ctx.moveTo(canvas.width/2, margin);
          ctx.lineTo(canvas.width/2, canvas.height - margin);
          ctx.stroke();

          // Koło środkowe
          ctx.beginPath();
          ctx.arc(canvas.width/2, canvas.height/2, 60, 0, Math.PI * 2);
          ctx.stroke();
          // Punkt środkowy
           ctx.beginPath();
           ctx.arc(canvas.width/2, canvas.height/2, 3, 0, Math.PI * 2);
           ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
           ctx.fill();


          // Bramki (słupki i poprzeczka - jako prostokąty dla lepszej wizualizacji)
          const goalWidth = 8; // Grubość słupka
          const goalHeight = 100; // Wysokość bramki
          const goalY = canvas.height/2 - goalHeight/2;
          ctx.fillStyle = "#DDDDDD"; // Kolor słupków
          // Bramka domowa
          ctx.fillRect(margin - goalWidth, goalY, goalWidth, goalHeight); // Zewnętrzny słupek
          // ctx.fillRect(margin, goalY - goalWidth, goalWidth * 2, goalWidth); // Poprzeczka (opcjonalnie)
          // ctx.fillRect(margin, goalY + goalHeight, goalWidth * 2, goalWidth); // Dolna część (opcjonalnie)

           // Bramka gości
           ctx.fillRect(canvas.width - margin, goalY, goalWidth, goalHeight);


          // Linie pola karnego (16.5m w przeliczeniu na proporcje)
          const penaltyAreaWidth = canvas.width * 0.18;
          const penaltyAreaHeight = canvas.height * 0.45;
          const penaltyAreaY = canvas.height/2 - penaltyAreaHeight/2;
          ctx.strokeRect(margin, penaltyAreaY, penaltyAreaWidth, penaltyAreaHeight); // Pole karne domowe
          ctx.strokeRect(canvas.width - margin - penaltyAreaWidth, penaltyAreaY, penaltyAreaWidth, penaltyAreaHeight); // Pole karne gości

           // Linie pola bramkowego (5.5m w przeliczeniu)
           const goalAreaWidth = canvas.width * 0.07;
           const goalAreaHeight = canvas.height * 0.2;
           const goalAreaY = canvas.height/2 - goalAreaHeight/2;
           ctx.strokeRect(margin, goalAreaY, goalAreaWidth, goalAreaHeight); // Pole bramkowe domowe
           ctx.strokeRect(canvas.width - margin - goalAreaWidth, goalAreaY, goalAreaWidth, goalAreaHeight); // Pole bramkowe gości

            // Punkty karne (opcjonalnie)
            const penaltySpotXHome = margin + canvas.width * 0.12;
            const penaltySpotXAway = canvas.width - margin - canvas.width * 0.12;
            ctx.beginPath();
            ctx.arc(penaltySpotXHome, canvas.height / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(penaltySpotXAway, canvas.height / 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Łuki pola karnego (opcjonalnie)
            ctx.beginPath();
            ctx.arc(penaltySpotXHome, canvas.height / 2, canvas.width * 0.08, Math.PI * 1.6, Math.PI * 0.4); // Dostosuj kąty
            ctx.stroke();
             ctx.beginPath();
             ctx.arc(penaltySpotXAway, canvas.height / 2, canvas.width * 0.08, Math.PI * 0.6, Math.PI * 1.4); // Dostosuj kąty
             ctx.stroke();
        }

        function drawGameObjects() {
           // Rysowanie piłki
           ctx.beginPath();
           ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
           ctx.fillStyle = ball.color;
           ctx.fill();
           // Cień pod piłką (opcjonalny)
           ctx.beginPath();
           ctx.ellipse(ball.x, ball.y + ball.radius * 0.8, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2);
           ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
           ctx.fill();
           ctx.closePath();


           // Funkcja pomocnicza do rysowania zawodnika z obwódką i cieniem
           const drawPlayer = (player, outlineColor) => {
               // Cień
               ctx.beginPath();
               ctx.ellipse(player.x, player.y + player.radius * 0.8, player.radius * 0.8, player.radius * 0.3, 0, 0, Math.PI * 2);
               ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
               ctx.fill();
               // Zawodnik
               ctx.beginPath();
               ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
               ctx.fillStyle = player.color;
               ctx.fill();
               // Obwódka
               ctx.strokeStyle = outlineColor;
               ctx.lineWidth = 2;
               ctx.stroke();
               ctx.closePath();
           };

           // Rysowanie zawodników drużyny domowej (biała obwódka)
           fieldPlayers.forEach(player => drawPlayer(player, "white"));
           drawPlayer(goalkeeper, "white"); // Bramkarz domowy

           // Rysowanie zawodników drużyny gościa (czarna obwódka)
           fieldPlayersAway.forEach(player => drawPlayer(player, "black"));
           drawPlayer(goalkeeperAway, "black"); // Bramkarz gościa


           // Rysowanie strzałki naciągu (tylko gdy przeciągamy)
           if (isDragging && draggingPlayerIndex !== null && dragStart && dragCurrent) {
               let playerDragged;
                if (draggingPlayerIndex === -1) playerDragged = goalkeeper;
                else playerDragged = fieldPlayers[draggingPlayerIndex];

               if (playerDragged) { // Upewnij się, że gracz istnieje
                   ctx.save();
                   ctx.beginPath();
                   ctx.moveTo(playerDragged.x, playerDragged.y);
                   // Linia wskazuje kierunek przeciwny do przeciągania (kierunek strzału)
                   let targetX = playerDragged.x - (dragCurrent.x - dragStart.x);
                   let targetY = playerDragged.y - (dragCurrent.y - dragStart.y);

                   // Ogranicz długość wizualną linii
                   let dx = targetX - playerDragged.x;
                   let dy = targetY - playerDragged.y;
                   let length = Math.hypot(dx, dy);
                   const visualMaxLength = 80;
                   if (length > visualMaxLength) {
                       targetX = playerDragged.x + (dx / length) * visualMaxLength;
                       targetY = playerDragged.y + (dy / length) * visualMaxLength;
                       length = visualMaxLength; // Użyj ograniczonej długości do koloru
                   }

                   // Kolor i grubość linii zależna od siły
                   let strengthRatio = Math.min(length / visualMaxLength, 1);
                   let red = Math.floor(255 * strengthRatio);
                   let green = Math.floor(255 * (1 - strengthRatio));
                   ctx.strokeStyle = `rgb(${red}, ${green}, 0)`;
                   ctx.lineWidth = 1 + 3 * strengthRatio; // Grubość od 1 do 4
                   ctx.setLineDash([6, 4]); // Przerywana linia

                   ctx.lineTo(targetX, targetY);
                   ctx.stroke();

                   // Grot strzałki (opcjonalnie)
                    if (length > 10) { // Rysuj grot tylko dla znaczącego naciągu
                        let angle = Math.atan2(targetY - playerDragged.y, targetX - playerDragged.x);
                        ctx.lineTo(targetX - 10 * Math.cos(angle - Math.PI / 6), targetY - 10 * Math.sin(angle - Math.PI / 6));
                        ctx.moveTo(targetX, targetY);
                        ctx.lineTo(targetX - 10 * Math.cos(angle + Math.PI / 6), targetY - 10 * Math.sin(angle + Math.PI / 6));
                        ctx.stroke();
                    }

                   ctx.restore();
               }
           }
       }


        function updatePositions() {
            const margin = 5; // Taki sam margines jak przy rysowaniu boiska

             // Funkcja pomocnicza do aktualizacji pozycji i odbić gracza
            const updatePlayer = (player) => {
                player.x += player.vx;
                player.y += player.vy;

                // Ograniczenie maksymalnej prędkości
                const speed = Math.hypot(player.vx, player.vy);
                if (speed > MAX_PLAYER_SPEED) {
                    player.vx = (player.vx / speed) * MAX_PLAYER_SPEED;
                    player.vy = (player.vy / speed) * MAX_PLAYER_SPEED;
                }


                // Odbicie od ścian bocznych
                if (player.x - player.radius < margin) { player.x = margin + player.radius; player.vx *= -WALL_RESTITUTION; }
                if (player.x + player.radius > canvas.width - margin) { player.x = canvas.width - margin - player.radius; player.vx *= -WALL_RESTITUTION; }
                // Odbicie od ścian górnej i dolnej
                if (player.y - player.radius < margin) { player.y = margin + player.radius; player.vy *= -WALL_RESTITUTION; }
                if (player.y + player.radius > canvas.height - margin) { player.y = canvas.height - margin - player.radius; player.vy *= -WALL_RESTITUTION; }

                 // Zastosuj tarcie
                 player.vx *= FRICTION;
                 player.vy *= FRICTION;
            };

            // Aktualizacja zawodników domowych i gości
            fieldPlayers.forEach(updatePlayer);
            fieldPlayersAway.forEach(updatePlayer);

            // Aktualizacja bramkarzy (proste AI ruchu pionowego + ograniczenia)
             const updateGoalkeeper = (gk, targetX) => {
                // Proste śledzenie piłki w osi Y
                let targetY_GK = ball.y;
                // Ograniczenie ruchu bramkarza do wysokości pola karnego
                const penaltyAreaHeight = canvas.height * 0.45;
                const minY_GK = canvas.height / 2 - penaltyAreaHeight / 2 + gk.radius + margin;
                const maxY_GK = canvas.height / 2 + penaltyAreaHeight / 2 - gk.radius - margin;
                targetY_GK = Math.max(minY_GK, Math.min(maxY_GK, targetY_GK));

                let dyGK = targetY_GK - gk.y;
                let speedGK = 1.8; // Szybkość bramkarza
                if (Math.abs(dyGK) > 1) { // Mały próg, aby uniknąć drgania
                     gk.vy = Math.sign(dyGK) * speedGK;
                } else {
                     gk.vy = 0;
                }

                 gk.x = targetX; // Stała pozycja X
                 gk.y += gk.vy;
                 gk.vy *= FRICTION; // Tarcie dla bramkarza
                 // Upewnij się, że bramkarz nie wyjdzie poza boisko w osi Y (dodatkowe zabezpieczenie)
                 gk.y = Math.max(margin + gk.radius, Math.min(canvas.height - margin - gk.radius, gk.y));
                 // Upewnij się, że bramkarz nie wyjdzie za bardzo do przodu
                 if (targetX < canvas.width / 2) { // Bramkarz domowy
                     gk.x = Math.max(targetX, gk.x); // Nie może iść dalej niż targetX
                 } else { // Bramkarz gości
                     gk.x = Math.min(targetX, gk.x); // Nie może iść dalej niż targetX
                 }
            };

             updateGoalkeeper(goalkeeper, 40); // Bramkarz domowy na x=40
             updateGoalkeeper(goalkeeperAway, canvas.width - 40); // Bramkarz gości


           // Aktualizacja piłki
           ball.x += ball.dx;
           ball.y += ball.dy;
           ball.dx *= FRICTION * BALL_FRICTION; // Dodatkowe tarcie dla piłki
           ball.dy *= FRICTION * BALL_FRICTION;


           // Odbicie piłki od ścian górnej i dolnej
           if (ball.y - ball.radius < margin) { ball.y = margin + ball.radius; ball.dy *= -WALL_RESTITUTION; }
           if (ball.y + ball.radius > canvas.height - margin) { ball.y = canvas.height - margin - ball.radius; ball.dy *= -WALL_RESTITUTION; }

           // Sprawdzenie gola i odbicie od ścian bocznych (poza bramką)
           const goalHeight = 100;
           const goalTop = canvas.height/2 - goalHeight/2;
           const goalBottom = canvas.height/2 + goalHeight/2;
            let goalScored = false;

           // Gol dla gości?
           if (ball.x - ball.radius < margin) {
             if (ball.y > goalTop && ball.y < goalBottom) {
               score.away++;
               goalScored = true;
               resetPositionsAfterGoal(true); // Resetuj, zaczynają gospodarze
             } else {
               // Odbicie od słupka/ściany bocznej
               ball.x = margin + ball.radius;
               ball.dx *= -WALL_RESTITUTION;
             }
           }
           // Gol dla gospodarzy?
           if (ball.x + ball.radius > canvas.width - margin) {
             if (ball.y > goalTop && ball.y < goalBottom) {
               score.home++;
               goalScored = true;
               resetPositionsAfterGoal(false); // Resetuj, zaczynają goście
             } else {
                // Odbicie od słupka/ściany bocznej
               ball.x = canvas.width - margin - ball.radius;
               ball.dx *= -WALL_RESTITUTION;
             }
           }

            // Zaktualizuj tablicę wyników jeśli padł gol
           if (goalScored) {
                document.getElementById("scoreboard").innerText =
                    `${selectedHomeTeam} ${score.home} : ${score.away} ${selectedAwayTeam}`;
           }
        }


        function resetPositionsAfterGoal(homeTeamScored) {
           ball.x = canvas.width / 2;
           ball.y = canvas.height / 2;
           ball.dx = 0; // Start bez ruchu po golu
           ball.dy = 0;

           // Kto zaczyna? Można dodać lekkie podanie do przodu
           /*
           if (homeTeamScored) { // Zaczynają goście (AI)
               // ball.dx = -1; ball.dy = (Math.random() - 0.5) * 1;
           } else { // Zaczynają gospodarze (gracz)
               // ball.dx = 1; ball.dy = (Math.random() - 0.5) * 1;
           }
           */

            // Reset pozycji zawodników do formacji początkowej
            let homeColor = getTeamColor(selectedHomeTeam);
            let awayColor = getTeamColor(selectedAwayTeam);

             fieldPlayers = [
                { x: canvas.width * 0.20, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                { x: canvas.width * 0.20, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                { x: canvas.width * 0.35, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor },
                //{ x: canvas.width * 0.40, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: homeColor }
             ];

             fieldPlayersAway = [
                { x: canvas.width * 0.80, y: canvas.height * 0.3, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                { x: canvas.width * 0.80, y: canvas.height * 0.7, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                { x: canvas.width * 0.65, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor },
                //{ x: canvas.width * 0.60, y: canvas.height * 0.5, radius: PLAYER_RADIUS, vx: 0, vy: 0, color: awayColor }
             ];

             goalkeeper = { x: 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: homeColor };
             goalkeeperAway = { x: canvas.width - 40, y: canvas.height/2, radius: GOALKEEPER_RADIUS, vx: 0, vy: 0, color: awayColor };

            // Krótka pauza po golu (opcjonalnie)
            // gameAnimating = false;
            // setTimeout(() => { gameAnimating = true; requestAnimationFrame(gameLoop); }, 1000);
        }

        function circleCollision(c1, c2) {
          const dx = c1.x - c2.x;
          const dy = c1.y - c2.y;
          const distance = Math.hypot(dx, dy);
          const radiiSum = c1.radius + c2.radius;
          return distance < radiiSum;
        }

        // =============================================================
        // === POPRAWIONA FUNKCJA resolveCollision (z poprzedniego kroku) ===
        // =============================================================
        function resolveCollision(c1, c2, isPlayerPlayerCollision = false) {
            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            let distance = Math.hypot(dx, dy);

            const epsilon = 0.01; // Zwiększono epsilon, aby zapobiegać sklejaniu
            if (distance < epsilon) {
                 distance = epsilon;
                 const randomAngle = Math.random() * Math.PI * 2;
                 const adjust = epsilon / 2;
                 c1.x -= Math.cos(randomAngle) * adjust;
                 c1.y -= Math.sin(randomAngle) * adjust;
                 c2.x += Math.cos(randomAngle) * adjust;
                 c2.y += Math.sin(randomAngle) * adjust;
                  // Przelicz dx i dy po minimalnym rozsunięciu
                 // dx = c2.x - c1.x; // Może nie być konieczne, jeśli tylko zapobiegamy NaN
                 // dy = c2.y - c1.y;
            }


            const radiiSum = c1.radius + c2.radius;
            const overlap = radiiSum - distance;

            if (overlap > 0) {
                // --- Rozsunięcie obiektów ---
                const adjustFactor = overlap / distance / 2;
                let adjustX = dx * adjustFactor;
                let adjustY = dy * adjustFactor;

                // Ograniczenie maksymalnej korekty pozycji
                const MAX_POSITION_CORRECTION = c1.radius * 0.5; // Ograniczenie do połowy promienia mniejszego obiektu
                const correctionMagnitude = Math.hypot(adjustX, adjustY);
                if (correctionMagnitude > MAX_POSITION_CORRECTION) {
                    const scale = MAX_POSITION_CORRECTION / correctionMagnitude;
                    adjustX *= scale;
                    adjustY *= scale;
                }

                // Zastosuj rozsunięcie (tylko jeśli obiekty nie są "nieruchome" - np. ściany)
                if (!c1.isStatic) {
                    c1.x -= adjustX;
                    c1.y -= adjustY;
                }
                if (!c2.isStatic) {
                    c2.x += adjustX;
                    c2.y += adjustY;
                }


                // --- Wymiana pędu ---
                const angle = Math.atan2(dy, dx);
                const sine = Math.sin(angle);
                const cosine = Math.cos(angle);

                // Obróć wektory prędkości c1 i c2
                let v1 = { x: c1.vx * cosine + c1.vy * sine, y: c1.vy * cosine - c1.vx * sine };
                let v2 = { x: c2.vx * cosine + c2.vy * sine, y: c2.vy * cosine - c2.vx * sine };

                // Użyj odpowiedniego współczynnika restytucji i tarcia
                 const restitution = isPlayerPlayerCollision ? PLAYER_RESTITUTION * 0.5 : PLAYER_RESTITUTION; // Mniejsza sprężystość gracz-gracz
                 const collisionFriction = isPlayerPlayerCollision ? PLAYER_COLLISION_FRICTION : 1.0; // Tarcie tylko gracz-gracz

                // Uproszczona masa jako kwadrat promienia (dla większego wpływu większych obiektów)
                const m1 = c1.radius * c1.radius;
                const m2 = c2.radius * c2.radius;
                const totalMass = m1 + m2;

                // Oblicz końcowe prędkości w osi X (po obrocie)
                let vFinal1_x = ((m1 - m2 * restitution) * v1.x + (m2 + m2 * restitution) * v2.x) / totalMass;
                let vFinal2_x = ((m1 + m1 * restitution) * v1.x + (m2 - m1 * restitution) * v2.x) / totalMass;

                 // Prędkości Y pozostają (prawie) bez zmian, ale dodajemy tarcie
                 v1.y *= collisionFriction;
                 v2.y *= collisionFriction;

                // Obróć wektory z powrotem
                c1.vx = (vFinal1_x * cosine - v1.y * sine);
                c1.vy = (v1.y * cosine + vFinal1_x * sine);
                c2.vx = (vFinal2_x * cosine - v2.y * sine);
                c2.vy = (v2.y * cosine + vFinal2_x * sine);
            }
        }
        // =============================================================
        // === KONIEC POPRAWIONEJ FUNKCJI resolveCollision           ===
        // =============================================================


        function checkCollisions() {
            const allPlayers = [...fieldPlayers, ...fieldPlayersAway, goalkeeper, goalkeeperAway];

            // Kolizje Gracz-Piłka
            allPlayers.forEach(player => {
                 if (circleCollision(player, ball)) {
                    resolveCollision(player, ball, false); // false -> nie jest to kolizja gracz-gracz
                 }
            });

             // Kolizje Gracz-Gracz
            for (let i = 0; i < allPlayers.length; i++) {
                for (let j = i + 1; j < allPlayers.length; j++) {
                    if (circleCollision(allPlayers[i], allPlayers[j])) {
                        resolveCollision(allPlayers[i], allPlayers[j], true); // true -> kolizja gracz-gracz
                    }
                }
            }
        }


        function aiMove() {
           const aiSpeed = 1.2; // Zwiększona bazowa szybkość AI
           const shootingRange = canvas.width * 0.4; // Z jakiej odległości AI próbuje strzelać (procent szerokości boiska)
           const optimalDistanceFactor = 4; // Jak blisko piłki chce być AI (mnożnik promienia gracza)
           const passProbability = 0.1; // Szansa na próbę podania zamiast strzału/ruchu do piłki
           const goalTargetX = 40 + GOALKEEPER_RADIUS; // Celuj w bramkę domową

           fieldPlayersAway.forEach((player, index) => {
               let dxToBall = ball.x - player.x;
               let dyToBall = ball.y - player.y;
               let distToBall = Math.hypot(dxToBall, dyToBall) || 1;

               let dxToGoal = goalTargetX - player.x;
               let dyToGoal = canvas.height / 2 - player.y; // Celuj w środek bramki
               let distToGoal = Math.hypot(dxToGoal, dyToGoal);

                let isClosestToBall = true; // Załóż, że ten gracz jest najbliżej
                for(let otherPlayer of fieldPlayersAway) {
                    if (otherPlayer !== player) {
                        if (Math.hypot(ball.x - otherPlayer.x, ball.y - otherPlayer.y) < distToBall) {
                            isClosestToBall = false;
                            break;
                        }
                    }
                }
                 // Jeśli nie jest najbliżej, może próbować się ustawić lepiej
                if (!isClosestToBall && player.x > canvas.width / 2) { // Tylko jeśli jest na połowie przeciwnika
                    // Prosta logika: idź w stronę "pustego" miejsca bliżej bramki
                    let targetX = canvas.width * 0.3 + Math.random() * canvas.width * 0.2;
                    let targetY = canvas.height * 0.2 + Math.random() * canvas.height * 0.6;
                     let dxToPos = targetX - player.x;
                     let dyToPos = targetY - player.y;
                     let distToPos = Math.hypot(dxToPos, dyToPos) || 1;
                     player.vx += (dxToPos / distToPos) * aiSpeed * 0.5;
                     player.vy += (dyToPos / distToPos) * aiSpeed * 0.5;
                     return; // Przejdź do następnego gracza
                }


                // ----- GŁÓWNA LOGIKA AI (dla najbliższego gracza lub gdy jest na własnej połowie) -----

               // 1. Decyzja: Strzał, Podanie czy Ruch do piłki?
                if (player.x > canvas.width * 0.55 && distToGoal < shootingRange && distToBall < player.radius + ball.radius + 15) { // Na połowie przeciwnika, w zasięgu, blisko piłki
                    // a) Szansa na podanie?
                    if (Math.random() < passProbability) {
                        let bestPassTarget = null;
                        let minPassDist = Infinity;
                        // Znajdź kolegę w dobrej pozycji (bliżej bramki)
                        fieldPlayersAway.forEach(teammate => {
                            if (teammate !== player && teammate.x < player.x) {
                                let dist = Math.hypot(teammate.x - player.x, teammate.y - player.y);
                                // Proste kryterium - najbliższy kolega przed nim
                                if (dist < minPassDist && dist < canvas.width * 0.3) { // Ogranicz zasięg podania
                                     minPassDist = dist;
                                     bestPassTarget = teammate;
                                }
                            }
                        });

                        if (bestPassTarget) {
                             // Podanie
                            let passStrength = 3 + Math.random() * 1.5;
                            let passAngle = Math.atan2(bestPassTarget.y - player.y, bestPassTarget.x - player.x);
                            // Nadaj pęd piłce
                            ball.dx = Math.cos(passAngle) * passStrength;
                            ball.dy = Math.sin(passAngle) * passStrength;
                             // Lekki ruch gracza w kierunku podania
                             player.vx += Math.cos(passAngle) * passStrength * 0.1;
                             player.vy += Math.sin(passAngle) * passStrength * 0.1;
                             return; // Akcja wykonana
                        }
                    }

                    // b) Jeśli nie podanie -> STRZAŁ
                    let shootStrength = 4.5 + Math.random() * 2.5; // Silniejszy strzał
                    // Celuj lekko losowo w bramkę (góra/dół)
                    let targetShootY = canvas.height / 2 + (Math.random() - 0.5) * (goalHeight * 0.8);
                    let shootAngle = Math.atan2(targetShootY - player.y, goalTargetX - player.x);
                     // Nadaj pęd piłce
                    ball.dx = Math.cos(shootAngle) * shootStrength;
                    ball.dy = Math.sin(shootAngle) * shootStrength;
                    // Lekki ruch gracza po strzale
                    player.vx += Math.cos(shootAngle) * shootStrength * 0.05;
                    player.vy += Math.sin(shootAngle) * shootStrength * 0.05;

                } else {
                    // 2. Ruch do piłki / Ustawianie się
                    let targetX = ball.x;
                    let targetY = ball.y;
                     let optimalDist = player.radius * optimalDistanceFactor;

                    // Jeśli jest za daleko, idź prosto do piłki
                    if (distToBall > optimalDist) {
                         player.vx += (dxToBall / distToBall) * aiSpeed * (Math.random() * 0.3 + 0.85); // Nieco wolniej z daleka
                         player.vy += (dyToBall / distToBall) * aiSpeed * (Math.random() * 0.3 + 0.85);
                    } else if (distToBall < optimalDist * 0.8 && player.x > canvas.width * 0.6) {
                        // Jeśli jest BARDZO blisko piłki na połowie przeciwnika -> lekko się odsuń w stronę własnej bramki, żeby zrobić miejsce na strzał/podanie
                         player.vx -= (dxToBall / distToBall) * aiSpeed * 0.5;
                         player.vy -= (dyToBall / distToBall) * aiSpeed * 0.5;
                    }
                     else {
                         // Jeśli jest w optymalnej odległości lub na własnej połowie,
                         // spróbuj ustawić się "za" piłką względem bramki przeciwnika
                        let angleToGoal = Math.atan2(canvas.height / 2 - ball.y, goalTargetX - ball.x);
                        targetX = ball.x + Math.cos(angleToGoal + Math.PI) * optimalDist * 0.7; // Cel za piłką
                        targetY = ball.y + Math.sin(angleToGoal + Math.PI) * optimalDist * 0.7;

                        let dxToTargetPos = targetX - player.x;
                        let dyToTargetPos = targetY - player.y;
                        let distToTargetPos = Math.hypot(dxToTargetPos, dyToTargetPos) || 1;

                        player.vx += (dxToTargetPos / distToTargetPos) * aiSpeed;
                        player.vy += (dyToTargetPos / distToTargetPos) * aiSpeed;
                    }
                }

                // Ograniczenie maksymalnej prędkości AI (przeniesione do updatePlayer)
           });
        }


        function gameLoop() {
          if (!gameAnimating) return; // Zatrzymaj pętlę, jeśli gra nie jest aktywna

          // --- Czyszczenie ---
          ctx.clearRect(0, 0, canvas.width, canvas.height); // Wyczyść canvas

          // --- Rysowanie tła/boiska ---
          drawField();

          // --- Logika gry ---
          if (!isDragging) { // AI wykonuje ruch tylko, gdy gracz nie przeciąga
             aiMove();
          }
          updatePositions(); // Aktualizuj pozycje wszystkich obiektów
          checkCollisions(); // Sprawdź i rozwiąż kolizje

          // --- Rysowanie obiektów ---
          drawGameObjects(); // Narysuj piłkę, graczy, strzałkę naciągu

          // --- Pętla ---
          requestAnimationFrame(gameLoop); // Poproś o następną klatkę animacji
        }

        /* OBSŁUGA PRZECIĄGANIA (STEROWANIE GRACZA) */
        function canvasMouseDown(e) {
          if (!gameAnimating) return; // Nie reaguj, jeśli gra nie jest aktywna
          const rect = canvas.getBoundingClientRect();
          // Współrzędne myszy/dotyku wewnątrz canvas
          const clientX = e.clientX || (e.touches && e.touches[0].clientX);
          const clientY = e.clientY || (e.touches && e.touches[0].clientY);
           if (clientX === undefined || clientY === undefined) return; // Brak danych o pozycji

          const mx = clientX - rect.left;
          const my = clientY - rect.top;

          draggingPlayerIndex = null; // Resetuj przed sprawdzeniem

          // Sprawdź kliknięcie na bramkarza domowego
          const gk = goalkeeper;
          if (Math.hypot(mx - gk.x, my - gk.y) < gk.radius + 10) { // Zwiększony obszar kliknięcia
              draggingPlayerIndex = -1; // Specjalny indeks dla bramkarza
          } else {
              // Sprawdź kliknięcie na zawodników z pola drużyny domowej
              for (let i = 0; i < fieldPlayers.length; i++) {
                  const p = fieldPlayers[i];
                  if (Math.hypot(mx - p.x, my - p.y) < p.radius + 10) { // Zwiększony obszar
                      draggingPlayerIndex = i;
                      break; // Znaleziono gracza, przerwij pętlę
                  }
              }
          }


          // Jeśli znaleziono gracza do przeciągnięcia
          if (draggingPlayerIndex !== null) {
              isDragging = true;
              let playerDragged = (draggingPlayerIndex === -1) ? goalkeeper : fieldPlayers[draggingPlayerIndex];
              // Zapisz pozycję startową myszy, a nie gracza
              dragStart = { x: mx, y: my };
              dragCurrent = { x: mx, y: my };
               // Zatrzymaj gracza podczas przeciągania (opcjonalnie, może dawać lepszą kontrolę)
               playerDragged.vx = 0;
               playerDragged.vy = 0;
          }
        }

        function canvasMouseMove(e) {
          if (!isDragging || !gameAnimating) return;
          const rect = canvas.getBoundingClientRect();
           const clientX = e.clientX || (e.touches && e.touches[0].clientX);
           const clientY = e.clientY || (e.touches && e.touches[0].clientY);
           if (clientX === undefined || clientY === undefined) return;

          dragCurrent.x = clientX - rect.left;
          dragCurrent.y = clientY - rect.top;
          // Wizualizacja naciągu jest aktualizowana w drawGameObjects
        }


        function canvasMouseUp(e) {
          if (!isDragging || draggingPlayerIndex === null || !gameAnimating) return;

          let playerToMove;
          if (draggingPlayerIndex === -1) { // Bramkarz
              playerToMove = goalkeeper;
          } else { // Zawodnik z pola
              playerToMove = fieldPlayers[draggingPlayerIndex];
          }

          // Wektor przeciągnięcia (od punktu puszczenia do punktu złapania)
          const dx = dragStart.x - dragCurrent.x;
          const dy = dragStart.y - dragCurrent.y;
          const dragDistance = Math.hypot(dx, dy);

          // Minimalny dystans przeciągnięcia, aby nadać ruch
          const minDragDistance = 10;

          if (dragDistance > minDragDistance) {
              // Ograniczenie siły impulsu na podstawie dystansu przeciągnięcia
              const maxEffectiveDrag = 150; // Maksymalny dystans wpływający na siłę
              const effectiveDrag = Math.min(dragDistance, maxEffectiveDrag);

              // Skaluj siłę impulsu
              const impulseMagnitude = (effectiveDrag / 5) * DRAG_IMPULSE_SCALE; // Dostosuj dzielnik dla czułości

              // Nadaj prędkość w kierunku przeciwnym do przeciągania
              playerToMove.vx = (dx / dragDistance) * impulseMagnitude;
              playerToMove.vy = (dy / dragDistance) * impulseMagnitude;

               // Ogranicz prędkość początkową nadaną przez przeciągnięcie
              const initialSpeed = Math.hypot(playerToMove.vx, playerToMove.vy);
               if (initialSpeed > MAX_PLAYER_SPEED * 1.5) { // Pozwól na nieco większy impuls początkowy
                  const scale = (MAX_PLAYER_SPEED * 1.5) / initialSpeed;
                  playerToMove.vx *= scale;
                  playerToMove.vy *= scale;
               }

          } else {
              // Jeśli przeciągnięcie było zbyt krótkie, nie nadawaj prędkości
              playerToMove.vx = 0;
              playerToMove.vy = 0;
          }


          isDragging = false;
          draggingPlayerIndex = null;
          dragStart = { x: 0, y: 0 }; // Resetuj punkty przeciągania
          dragCurrent = { x: 0, y: 0 };
        }

         // --- Obsługa dotyku ---
        function setupTouchEvents() {
            canvas.addEventListener("touchstart", (e) => {
                if (e.touches.length === 1) {
                    e.preventDefault(); // Zapobiegaj przewijaniu strony
                    canvasMouseDown(e);
                 }
            }, { passive: false }); // passive: false jest ważne dla preventDefault

             canvas.addEventListener("touchmove", (e) => {
                 if (e.touches.length === 1) {
                    e.preventDefault();
                    canvasMouseMove(e);
                 }
             }, { passive: false });

            canvas.addEventListener("touchend", (e) => {
                 // Touchend nie ma informacji o pozycji ostatniego dotyku,
                 // ale mouseUp używa `dragCurrent`, które było aktualizowane w touchmove
                 e.preventDefault();
                 canvasMouseUp(e); // Wywołaj logikę mouseUp
            });

            canvas.addEventListener("touchcancel", (e) => {
                // Anuluj przeciąganie, jeśli dotyk został przerwany
                 isDragging = false;
                 draggingPlayerIndex = null;
            });
        }


        /* INICJALIZACJA I OBSŁUGA ZDARZEŃ UI */

        function populateTeamSelections() {
            const homeContainer = document.getElementById("homeTeamContainer");
            const awayContainer = document.getElementById("awayTeamContainer");
            homeContainer.innerHTML = ""; // Wyczyść przed wypełnieniem
            awayContainer.innerHTML = ""; // Wyczyść przed wypełnieniem
            selectedHomeTeam = null; // Resetuj wybór
            selectedAwayTeam = null;
            startMatchFromSelectBtn.disabled = true; // Wyłącz przycisk na starcie
            selectedHomeTeamNameSpan.textContent = "";
            selectedAwayTeamNameSpan.textContent = "";


             // Sprawdź i aktywuj przycisk startu
            const checkStartButton = () => {
                if (selectedHomeTeam && selectedAwayTeam && selectedHomeTeam !== selectedAwayTeam) {
                    startMatchFromSelectBtn.disabled = false;
                    startMatchFromSelectBtn.textContent = "Rozpocznij Mecz";
                 } else if (selectedHomeTeam && selectedAwayTeam && selectedHomeTeam === selectedAwayTeam) {
                     startMatchFromSelectBtn.disabled = true;
                     startMatchFromSelectBtn.textContent = "Wybierz różne drużyny";
                 }
                 else {
                    startMatchFromSelectBtn.disabled = true;
                     startMatchFromSelectBtn.textContent = "Wybierz obie drużyny";
                }
            };


            // Funkcja pomocnicza do tworzenia opcji drużyny
            const createTeamOption = (team, containerType) => {
                let teamDiv = document.createElement("div");
                teamDiv.className = "team-option";
                teamDiv.dataset.team = team.name;
                teamDiv.title = team.name; // Tooltip z pełną nazwą
                teamDiv.innerHTML = `<img src="${team.logo}" alt="${team.name}" loading="lazy" /><p>${team.name}</p>`; // Użyj nazwy z obiektu team

                teamDiv.addEventListener("click", function () {
                    const containerElement = containerType === 'home' ? homeContainer : awayContainer;
                    const isSelected = this.classList.contains("selected");

                    // Odznacz wszystkie w tym kontenerze
                    Array.from(containerElement.querySelectorAll('.team-option')).forEach(el => el.classList.remove("selected"));

                     // Zaznacz/Odznacz kliknięty i zaktualizuj zmienną
                     if (!isSelected) {
                         this.classList.add("selected");
                         if (containerType === 'home') {
                            selectedHomeTeam = team.name;
                            selectedHomeTeamNameSpan.textContent = `(${team.name})`;
                         } else {
                            selectedAwayTeam = team.name;
                             selectedAwayTeamNameSpan.textContent = `(${team.name})`;
                        }
                    } else {
                        // Jeśli kliknięto już zaznaczoną, odznacz ją
                         if (containerType === 'home') {
                             selectedHomeTeam = null;
                             selectedHomeTeamNameSpan.textContent = "";
                         } else {
                            selectedAwayTeam = null;
                             selectedAwayTeamNameSpan.textContent = "";
                         }
                    }

                    console.log("Home:", selectedHomeTeam, "Away:", selectedAwayTeam);
                    checkStartButton(); // Sprawdź, czy można aktywować przycisk startu
                });
                return teamDiv;
            };


            // Wypełnianie kontenerów ligami i drużynami
            for (let league in teamsData) {
                // --- Drużyna Domowa ---
                let leagueHeaderHome = document.createElement("div"); // Użyj div zamiast h4 dla elastyczności
                leagueHeaderHome.className = "league-header";
                leagueHeaderHome.innerHTML = `<img src="${teamsData[league].leagueLogo}" alt="${league}" loading="lazy"> ${league}`;
                homeContainer.appendChild(leagueHeaderHome);

                let teamRowHome = document.createElement('div');
                teamRowHome.className = 'team-row';
                teamsData[league].teams.forEach(team => {
                    teamRowHome.appendChild(createTeamOption(team, 'home'));
                });
                homeContainer.appendChild(teamRowHome);

                // --- Drużyna Gościa ---
                let leagueHeaderAway = document.createElement("div");
                leagueHeaderAway.className = "league-header";
                leagueHeaderAway.innerHTML = `<img src="${teamsData[league].leagueLogo}" alt="${league}" loading="lazy"> ${league}`;
                awayContainer.appendChild(leagueHeaderAway);

                let teamRowAway = document.createElement('div');
                teamRowAway.className = 'team-row';
                teamsData[league].teams.forEach(team => {
                    teamRowAway.appendChild(createTeamOption(team, 'away'));
                });
                awayContainer.appendChild(teamRowAway);
            }
             checkStartButton(); // Sprawdź stan przycisku po załadowaniu
        }


        // Główny event listener po załadowaniu DOM
        document.addEventListener("DOMContentLoaded", () => {

          // Przycisk startu z ekranu głównego -> Pokaż wybór drużyn
          document.getElementById("startMatchBtn").addEventListener("click", () => {
            document.getElementById("startScreen").classList.add("hidden");
            document.getElementById("teamSelectScreen").classList.remove("hidden");
            populateTeamSelections(); // Wypełnij opcje drużyn
          });

          // Przycisk rozpoczęcia meczu z ekranu wyboru drużyn -> Rozpocznij grę
          startMatchFromSelectBtn.addEventListener("click", () => {
             // Sprawdzenie jest już w checkStartButton, ale dla pewności
            if (!selectedHomeTeam || !selectedAwayTeam || selectedHomeTeam === selectedAwayTeam) {
              console.error("Próba startu meczu bez wybranych lub z tymi samymi drużynami.");
              return;
            }

            console.log("Rozpoczynanie meczu:", selectedHomeTeam, "-", selectedAwayTeam);
            document.getElementById("teamSelectScreen").classList.add("hidden"); // Ukryj wybór drużyn
            document.getElementById("gameScreen").classList.remove("hidden"); // Pokaż ekran gry

            initGame(); // Zainicjuj stan gry (piłka, gracze, wynik)
            setupTouchEvents(); // Ustaw obsługę dotyku
            canvas.addEventListener("mousedown", canvasMouseDown); // Dodaj obsługę myszy
            canvas.addEventListener("mousemove", canvasMouseMove);
            canvas.addEventListener("mouseup", canvasMouseUp);
            canvas.addEventListener("mouseleave", canvasMouseUp); // Zakończ przeciąganie, gdy mysz opuści canvas


            startTimer(); // Włącz stoper
            gameAnimating = true; // Ustaw flagę animacji

            // === ODTWÓRZ MUZYKĘ ===
            if (backgroundMusic) {
               // Spróbuj odtworzyć, obsłuż potencjalny błąd (np. autoodtwarzanie zablokowane przez przeglądarkę)
                var playPromise = backgroundMusic.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        // Odtwarzanie rozpoczęte pomyślnie
                         console.log("Muzyka gra.");
                    }).catch(error => {
                        // Autoodtwarzanie nie powiodło się - często wymaga interakcji użytkownika
                        console.warn("Nie można automatycznie odtworzyć muzyki:", error);
                        // Można tu dodać przycisk "Włącz muzykę" lub informację dla użytkownika
                    });
                }
            } else {
                 console.warn("Nie znaleziono elementu audio #backgroundMusic");
            }

            requestAnimationFrame(gameLoop); // Rozpocznij pętlę gry
          });

          // Przycisk powrotu do menu z ekranu gry
          document.getElementById("backToStartBtn").addEventListener("click", () => {
            gameAnimating = false; // Zatrzymaj animację
            stopTimer(); // Zatrzymaj stoper

            // === ZATRZYMAJ MUZYKĘ ===
            if (backgroundMusic) {
              backgroundMusic.pause();
              backgroundMusic.currentTime = 0; // Resetuj czas odtwarzania
              console.log("Muzyka zatrzymana.");
            }

             // Usuń listenery canvas, aby uniknąć problemów po restarcie
             canvas.removeEventListener("mousedown", canvasMouseDown);
             canvas.removeEventListener("mousemove", canvasMouseMove);
             canvas.removeEventListener("mouseup", canvasMouseUp);
             canvas.removeEventListener("mouseleave", canvasMouseUp);
              // Można też usunąć listenery dotyku, jeśli były dodane

            resetGameToMenu(); // Pokaż menu główne
          });

          // Inne przyciski (np. Baza zawodników) - można dodać ich obsługę później
           /*
          document.getElementById("btnPlayerDB").addEventListener("click", () => {
              document.getElementById("playerDBModal").classList.remove("hidden");
              // Tutaj logika ładowania/wyświetlania bazy danych
          });
           document.getElementById("closePlayerDBBtn").addEventListener("click", () => {
               document.getElementById("playerDBModal").classList.add("hidden");
           });
           */

        }); // Koniec DOMContentLoaded

      })(); // Koniec IIFE
    </script>
  </body>
</html>
